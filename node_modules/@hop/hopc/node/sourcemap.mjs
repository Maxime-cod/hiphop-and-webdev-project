/*=====================================================================*/
/*    .../project/hop/hop/node_modules/hopc/node/sourcemap.mjs         */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Feb 19 07:25:45 2024                          */
/*    Last change :  Tue Mar 19 13:52:42 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Encode/Decode sourcemap files                                    */
/*    -------------------------------------------------------------    */
/*    See https://sourcemaps.info/spec.html                            */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { openSync, closeSync } from "fs";
import * as vlq from "./base64-vlq.mjs";
import { readFileSync } from "node:fs";

export { load, decode, encode, remap };

/*---------------------------------------------------------------------*/
/*    load ...                                                         */
/*    -------------------------------------------------------------    */
/*    Load a source map file.                                          */
/*---------------------------------------------------------------------*/
function load(file) {
   return decode(JSON.parse(readFileSync(file)));
}

/*---------------------------------------------------------------------*/
/*    decode ...                                                       */
/*    -------------------------------------------------------------    */
/*    Decode a JSON source map. Return a array of lines. Each line is  */
/*    an array of { tgtCol, source, srcLine, srcCol, name }            */
/*---------------------------------------------------------------------*/
function decode(sourceMap) {
   const { version, file, sources, names, mappings } = sourceMap;

   if (version !== 3) {
      throw `decode: unsupported Source Map version number ${version}`;
   }

   const lines =  mappings.split(";")
      .map(g => g.split(",").filter(n => n).map(decodeSegment));

   // patch the relative segement counters that appart col are all
   // relative to the previous occurrence of the counter
   for (let i = 0, srcIndex = 0, srcLine = 0, srcCol = 0, srcName = 0;
	i < lines.length;
	i++) {
      const segs = lines[i];
      for (let j = 0; j < segs.length; j++) {
	 const seg = segs[j];
	 // columns are relative to the previous segment and are
	 // reset at each new line
	 if (j > 0) {
	    seg.tgtCol += segs[j - 1].tgtCol;
	 }

	 if (seg.srcIndex !== undefined) {
	    srcIndex += seg.srcIndex; seg.srcIndex = srcIndex;
	    srcLine += seg.srcLine; seg.srcLine = srcLine;
	    srcCol += seg.srcCol; seg.srcCol = srcCol;

	    if (seg.srcName !== undefined) {
	       srcName += seg.srcName; seg.srcName += srcName;
	       src.name = names[seg.srcName];
	    }
	 }
      }
   }
   
   return { version, file, sources, names, lines };
}
	 
/*---------------------------------------------------------------------*/
/*    decodeSegment ...                                                */
/*    -------------------------------------------------------------    */
/*    A segment is made of 1,4 or 5 variable length fields. The        */
/*    fields are:                                                      */
/*                                                                     */
/*      1. The zero-based starting column of the line in the           */
/*         generated code that the segment represents.                 */
/*      2. If present, an zero-based index into the "sources" list.    */
/*      3. If present, the zero-based starting line in the original    */
/*         source represented.                                         */
/*      4. If present, the zero-based starting column of the line      */
/*         in the source represented.                                  */
/*      5. If present, the zero-based index into the "names" list      */
/*         associated with this segment.                               */
/*---------------------------------------------------------------------*/
export function decodeSegment(str) {
   const len = str.length;

   const { value: tgtCol, index: iindex } = vlq.decode(str, 0);
   if (iindex === len) {
      // size 1 segment
      return { tgtCol, index: iindex };
   } else {
      const { value: srcIndex, index: lindex } = vlq.decode(str, iindex);
      const { value: srcLine, index: cindex } = vlq.decode(str, lindex);
      const { value: srcCol, index: nindex } = vlq.decode(str, cindex);
      
      if (nindex === len) {
	 // size 4 segment
	 return { tgtCol, srcIndex, srcLine, srcCol };
      } else {
	 // size 5 segment
	 const { value: srcName } = vlq.decode(str, nindex);
	 return { tgtCol, srcIndex, srcLine, srcCol, srcName };
      }
   }
}

/*---------------------------------------------------------------------*/
/*    encode ...                                                       */
/*    -------------------------------------------------------------    */
/*    Inverse of the decode function (see above).                      */
/*---------------------------------------------------------------------*/
function encode(lineMap) {
   const { version, file, sources, names, lines } = lineMap;
   let srcline = 0, srccol = 0;

   const mappings = lines.map(l => {
      if (l.length > 0) {
	 let components = [];
	 let tgtcol = 0;
	 l.forEach(s => {
	    components.push(vlq.encode(s.tgtCol - tgtcol)
	       + "A"
	       + vlq.encode(s.srcLine - srcline)
	       + vlq.encode(s.srcCol - srccol));
	    tgtcol = s.tgtCol;
	    srcline = s.srcLine;
	    srccol = s.srcCol;
	 });
	 return components.join(",");
      } else {
	 return "";
      }
   }).join(";");
	 
   return { version, file, sources, names, mappings };
}

/*---------------------------------------------------------------------*/
/*    remapLines ...                                                   */
/*---------------------------------------------------------------------*/
function remapLines(origline, tmplines) {
   return origline.map(s => {
      if (s.srcLine < tmplines.length) {
	 const oline = tmplines[s.srcLine];
	 const fs = oline.find(t => t.tgtCol >= s.srcCol);
	 if (fs) {
	    s.srcLine = fs.srcLine;
	    s.srcCol = fs.srcCol;
	 }
      }
   });
}

/*---------------------------------------------------------------------*/
/*    remap ...                                                        */
/*    -------------------------------------------------------------    */
/*    Remap TMP sourcemap file to point to an ORIG source file.        */
/*---------------------------------------------------------------------*/
function remap(orig, tmp) {
   const origmap = load(orig);
   const tmpmap = load(tmp);
   const origlines = origmap.lines;
   const tmplines = tmpmap.lines;
   origlines.forEach(l => remapLines(l, tmplines));
   origmap.sources = tmpmap.sources;

   return encode(origmap);
}
