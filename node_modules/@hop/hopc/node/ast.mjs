/* generated file (mkjsast), do not edit (10 March 2025) */

// generated by tools/mkjast.scm
"use strict"

import { cons, pairp, array2list, forEach } from "./list.mjs";

export function J2SNode(loc) {
  if (!new.target) {
    return new J2SNode({"loc": array2list(loc)});
  } else {
    this.$class = 'J2SNode';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SNode.prototype.duplicate = function(prop) {
   const o = new J2SNode({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SStmt(loc) {
  if (!new.target) {
    return new J2SStmt({"loc": array2list(loc)});
  } else {
    this.$class = 'J2SStmt';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SStmt.prototype = new J2SNode();
J2SStmt.prototype.duplicate = function(prop) {
   const o = new J2SStmt({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SMeta(loc, meta, debug, optim, stmt) {
  if (!new.target) {
    return new J2SMeta({"loc": array2list(loc), "meta": meta, "debug": debug, "optim": optim, "stmt": stmt});
  } else {
    this.$class = 'J2SMeta';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.meta = meta;
        this.debug = debug;
        this.optim = optim;
        this.stmt = stmt;
      } else {
        this.meta = undefined;
        this.debug = 0;
        this.optim = 0;
        Object.assign(this, loc);
       }
    }
  }
}
J2SMeta.prototype = new J2SStmt();
J2SMeta.prototype.duplicate = function(prop) {
   const o = new J2SMeta({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SSeq(loc, nodes) {
  if (!new.target) {
    return new J2SSeq({"loc": array2list(loc), "nodes": array2list(nodes)});
  } else {
    this.$class = 'J2SSeq';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.nodes = array2list(nodes);
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SSeq.prototype = new J2SStmt();
J2SSeq.prototype.duplicate = function(prop) {
   const o = new J2SSeq({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SBlock(loc, nodes, endloc) {
  if (!new.target) {
    return new J2SBlock({"loc": array2list(loc), "nodes": array2list(nodes), "endloc": array2list(endloc)});
  } else {
    this.$class = 'J2SBlock';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.nodes = array2list(nodes);
        this.endloc = array2list(endloc);
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SBlock.prototype = new J2SSeq();
J2SBlock.prototype.duplicate = function(prop) {
   const o = new J2SBlock({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SProgram(loc, nodes, endloc, mode, path, pcacheSize, rxcacheSize, callSize, name, main, module, cnsts, decls, types, headers, globals, directEval, sourceMap, imports, exports) {
  if (!new.target) {
    return new J2SProgram({"loc": array2list(loc), "nodes": array2list(nodes), "endloc": array2list(endloc), "mode": mode, "path": path, "pcacheSize": pcacheSize, "rxcacheSize": rxcacheSize, "callSize": callSize, "name": name, "main": main, "module": module, "cnsts": array2list(cnsts), "decls": array2list(decls), "types": array2list(types), "headers": array2list(headers), "globals": array2list(globals), "directEval": directEval, "sourceMap": sourceMap, "imports": array2list(imports), "exports": array2list(exports)});
  } else {
    this.$class = 'J2SProgram';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.nodes = array2list(nodes);
        this.endloc = array2list(endloc);
        this.mode = typeof(mode) === 'symbol' ? mode.toString().slice(7,-1) : mode;
        this.path = path;
        this["pcache-size"] = pcacheSize;
        this["rxcache-size"] = rxcacheSize;
        this["call-size"] = callSize;
        this.name = name;
        this.main = main;
        this.module = module;
        this.cnsts = array2list(cnsts);
        this.decls = array2list(decls);
        this.types = array2list(types);
        this.headers = array2list(headers);
        this.globals = array2list(globals);
        this["direct-eval"] = directEval;
        this["source-map"] = sourceMap;
        this.imports = array2list(imports);
        this.exports = array2list(exports);
      } else {
        this.mode = 'normal';
        this.pcacheSize = 0;
        this.rxcacheSize = 0;
        this.callSize = 0;
        this.name = false;
        this.main = false;
        this.module = false;
        this.cnsts = null;
        this.decls = null;
        this.types = null;
        this.headers = null;
        this.globals = null;
        this.directEval = true;
        this.sourceMap = false;
        this.imports = null;
        this.exports = null;
        Object.assign(this, loc);
       }
    }
  }
}
J2SProgram.prototype = new J2SBlock();
J2SProgram.prototype.duplicate = function(prop) {
   const o = new J2SProgram({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDecl(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional) {
  if (!new.target) {
    return new J2SDecl({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional});
  } else {
    this.$class = 'J2SDecl';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
      } else {
        this._scmid = false;
        this.key = 1;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDecl.prototype = new J2SStmt();
J2SDecl.prototype.duplicate = function(prop) {
   const o = new J2SDecl({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclDestructure(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional) {
  if (!new.target) {
    return new J2SDeclDestructure({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional});
  } else {
    this.$class = 'J2SDeclDestructure';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
      } else {
        this._scmid = false;
        this.key = 2;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclDestructure.prototype = new J2SDecl();
J2SDeclDestructure.prototype.duplicate = function(prop) {
   const o = new J2SDeclDestructure({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclRest(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, allocPolicy) {
  if (!new.target) {
    return new J2SDeclRest({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "allocPolicy": allocPolicy});
  } else {
    this.$class = 'J2SDeclRest';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this["alloc-policy"] = typeof(allocPolicy) === 'symbol' ? allocPolicy.toString().slice(7,-1) : allocPolicy;
      } else {
        this._scmid = false;
        this.key = 3;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.allocPolicy = 'heap';
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclRest.prototype = new J2SDecl();
J2SDeclRest.prototype.duplicate = function(prop) {
   const o = new J2SDeclRest({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclArguments(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, allocPolicy, argid, mode, fun) {
  if (!new.target) {
    return new J2SDeclArguments({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "allocPolicy": allocPolicy, "argid": argid, "mode": mode, "fun": fun});
  } else {
    this.$class = 'J2SDeclArguments';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this["alloc-policy"] = typeof(allocPolicy) === 'symbol' ? allocPolicy.toString().slice(7,-1) : allocPolicy;
        this.argid = typeof(argid) === 'symbol' ? argid.toString().slice(7,-1) : argid;
        this.mode = typeof(mode) === 'symbol' ? mode.toString().slice(7,-1) : mode;
        this.fun = fun;
      } else {
        this._scmid = false;
        this.key = 4;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.allocPolicy = 'heap';
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclArguments.prototype = new J2SDeclRest();
J2SDeclArguments.prototype.duplicate = function(prop) {
   const o = new J2SDeclArguments({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclInit(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val) {
  if (!new.target) {
    return new J2SDeclInit({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val});
  } else {
    this.$class = 'J2SDeclInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
      } else {
        this._scmid = false;
        this.key = 5;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclInit.prototype = new J2SDecl();
J2SDeclInit.prototype.duplicate = function(prop) {
   const o = new J2SDeclInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclInitDestructure(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val) {
  if (!new.target) {
    return new J2SDeclInitDestructure({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val});
  } else {
    this.$class = 'J2SDeclInitDestructure';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
      } else {
        this._scmid = false;
        this.key = 6;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclInitDestructure.prototype = new J2SDeclInit();
J2SDeclInitDestructure.prototype.duplicate = function(prop) {
   const o = new J2SDeclInitDestructure({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclFun(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val, expression) {
  if (!new.target) {
    return new J2SDeclFun({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val, "expression": expression});
  } else {
    this.$class = 'J2SDeclFun';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
        this.expression = expression;
      } else {
        this._scmid = false;
        this.key = 7;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.expression = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclFun.prototype = new J2SDeclInit();
J2SDeclFun.prototype.duplicate = function(prop) {
   const o = new J2SDeclFun({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclFunType(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val, expression) {
  if (!new.target) {
    return new J2SDeclFunType({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val, "expression": expression});
  } else {
    this.$class = 'J2SDeclFunType';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
        this.expression = expression;
      } else {
        this._scmid = false;
        this.key = 8;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.expression = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclFunType.prototype = new J2SDeclFun();
J2SDeclFunType.prototype.duplicate = function(prop) {
   const o = new J2SDeclFunType({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclSvc(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val, expression) {
  if (!new.target) {
    return new J2SDeclSvc({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val, "expression": expression});
  } else {
    this.$class = 'J2SDeclSvc';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
        this.expression = expression;
      } else {
        this._scmid = false;
        this.key = 9;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.expression = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclSvc.prototype = new J2SDeclFun();
J2SDeclSvc.prototype.duplicate = function(prop) {
   const o = new J2SDeclSvc({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclClass(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val) {
  if (!new.target) {
    return new J2SDeclClass({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val});
  } else {
    this.$class = 'J2SDeclClass';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
      } else {
        this._scmid = false;
        this.key = 10;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclClass.prototype = new J2SDeclInit();
J2SDeclClass.prototype.duplicate = function(prop) {
   const o = new J2SDeclClass({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclExtern(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, val, bind, hiddenClass, raiseOnWrite, sweepable, configurable) {
  if (!new.target) {
    return new J2SDeclExtern({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "val": val, "bind": bind, "hiddenClass": hiddenClass, "raiseOnWrite": raiseOnWrite, "sweepable": sweepable, "configurable": configurable});
  } else {
    this.$class = 'J2SDeclExtern';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.val = val;
        this.bind = bind;
        this["hidden-class"] = hiddenClass;
        this["raise-on-write"] = raiseOnWrite;
        this.sweepable = typeof(sweepable) === 'symbol' ? sweepable.toString().slice(7,-1) : sweepable;
        this.configurable = configurable;
      } else {
        this._scmid = false;
        this.key = 11;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.bind = false;
        this.hiddenClass = true;
        this.raiseOnWrite = false;
        this.sweepable = 'scheme';
        this.configurable = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclExtern.prototype = new J2SDeclInit();
J2SDeclExtern.prototype.duplicate = function(prop) {
   const o = new J2SDeclExtern({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclImport(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional, alias, $$import) {
  if (!new.target) {
    return new J2SDeclImport({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional, "alias": alias, "$$import": $$import});
  } else {
    this.$class = 'J2SDeclImport';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
        this.alias = alias;
        this.import = $$import;
      } else {
        this._scmid = false;
        this.key = 12;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        this.alias = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclImport.prototype = new J2SDecl();
J2SDeclImport.prototype.duplicate = function(prop) {
   const o = new J2SDeclImport({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDeclInterface(loc, id, _scmid, key, writable, scope, usecnt, useinloop, escape, usage, binder, ctype, utype, itype, vtype, mtype, irange, vrange, hint, $$export, optional) {
  if (!new.target) {
    return new J2SDeclInterface({"loc": array2list(loc), "id": id, "_scmid": _scmid, "key": key, "writable": writable, "scope": scope, "usecnt": usecnt, "useinloop": useinloop, "escape": escape, "usage": usage, "binder": binder, "ctype": ctype, "utype": utype, "itype": itype, "vtype": vtype, "mtype": mtype, "irange": irange, "vrange": vrange, "hint": array2list(hint), "$$export": $$export, "optional": optional});
  } else {
    this.$class = 'J2SDeclInterface';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this._scmid = _scmid;
        this.key = key;
        this.writable = writable;
        this.scope = typeof(scope) === 'symbol' ? scope.toString().slice(7,-1) : scope;
        this.usecnt = usecnt;
        this.useinloop = useinloop;
        this.escape = escape;
        this.usage = usage;
        this.binder = typeof(binder) === 'symbol' ? binder.toString().slice(7,-1) : binder;
        this.ctype = ctype;
        this.utype = utype;
        this.itype = itype;
        this.vtype = vtype;
        this.mtype = mtype;
        this.irange = irange;
        this.vrange = vrange;
        this.hint = array2list(hint);
        this.export = $$export;
        this.optional = optional;
      } else {
        this._scmid = false;
        this.key = 13;
        this.writable = true;
        this.scope = 'local';
        this.usecnt = 0;
        this.useinloop = false;
        this.escape = false;
        this.usage = ~~0;
        this.binder = 'var';
        this.ctype = 'any';
        this.utype = 'unknown';
        this.itype = 'unknown';
        this.vtype = 'unknown';
        this.mtype = 'unknown';
        this.irange = undefined;
        this.vrange = undefined;
        this.hint = null;
        this.$$export = false;
        this.optional = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDeclInterface.prototype = new J2SDecl();
J2SDeclInterface.prototype.duplicate = function(prop) {
   const o = new J2SDeclInterface({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SExpr(loc, type, hint, range) {
  if (!new.target) {
    return new J2SExpr({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range});
  } else {
    this.$class = 'J2SExpr';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SExpr.prototype = new J2SNode();
J2SExpr.prototype.duplicate = function(prop) {
   const o = new J2SExpr({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCast(loc, type, hint, range, $$static, expr) {
  if (!new.target) {
    return new J2SCast({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "$$static": $$static, "expr": expr});
  } else {
    this.$class = 'J2SCast';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.static = $$static;
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.$$static = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCast.prototype = new J2SExpr();
J2SCast.prototype.duplicate = function(prop) {
   const o = new J2SCast({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCheck(loc, type, hint, range, expr) {
  if (!new.target) {
    return new J2SCheck({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "expr": expr});
  } else {
    this.$class = 'J2SCheck';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCheck.prototype = new J2SExpr();
J2SCheck.prototype.duplicate = function(prop) {
   const o = new J2SCheck({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SStmtExpr(loc, expr) {
  if (!new.target) {
    return new J2SStmtExpr({"loc": array2list(loc), "expr": expr});
  } else {
    this.$class = 'J2SStmtExpr';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.expr = expr;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SStmtExpr.prototype = new J2SStmt();
J2SStmtExpr.prototype.duplicate = function(prop) {
   const o = new J2SStmtExpr({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SIf(loc, test, then, $$else) {
  if (!new.target) {
    return new J2SIf({"loc": array2list(loc), "test": test, "then": then, "$$else": $$else});
  } else {
    this.$class = 'J2SIf';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.test = test;
        this.then = then;
        this.else = $$else;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SIf.prototype = new J2SStmt();
J2SIf.prototype.duplicate = function(prop) {
   const o = new J2SIf({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SPrecache(loc, test, then, $$else, accesses) {
  if (!new.target) {
    return new J2SPrecache({"loc": array2list(loc), "test": test, "then": then, "$$else": $$else, "accesses": array2list(accesses)});
  } else {
    this.$class = 'J2SPrecache';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.test = test;
        this.then = then;
        this.else = $$else;
        this.accesses = array2list(accesses);
      } else {
        this.accesses = null;
        Object.assign(this, loc);
       }
    }
  }
}
J2SPrecache.prototype = new J2SIf();
J2SPrecache.prototype.duplicate = function(prop) {
   const o = new J2SPrecache({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SIfIsRecord(loc, test, then, $$else) {
  if (!new.target) {
    return new J2SIfIsRecord({"loc": array2list(loc), "test": test, "then": then, "$$else": $$else});
  } else {
    this.$class = 'J2SIfIsRecord';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.test = test;
        this.then = then;
        this.else = $$else;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SIfIsRecord.prototype = new J2SIf();
J2SIfIsRecord.prototype.duplicate = function(prop) {
   const o = new J2SIfIsRecord({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SIfArgDefVal(loc, test, then, $$else) {
  if (!new.target) {
    return new J2SIfArgDefVal({"loc": array2list(loc), "test": test, "then": then, "$$else": $$else});
  } else {
    this.$class = 'J2SIfArgDefVal';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.test = test;
        this.then = then;
        this.else = $$else;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SIfArgDefVal.prototype = new J2SIf();
J2SIfArgDefVal.prototype.duplicate = function(prop) {
   const o = new J2SIfArgDefVal({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SVarDecls(loc, decls) {
  if (!new.target) {
    return new J2SVarDecls({"loc": array2list(loc), "decls": array2list(decls)});
  } else {
    this.$class = 'J2SVarDecls';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.decls = array2list(decls);
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SVarDecls.prototype = new J2SStmt();
J2SVarDecls.prototype.duplicate = function(prop) {
   const o = new J2SVarDecls({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLetBlock(loc, nodes, endloc, rec, decls, mode) {
  if (!new.target) {
    return new J2SLetBlock({"loc": array2list(loc), "nodes": array2list(nodes), "endloc": array2list(endloc), "rec": rec, "decls": array2list(decls), "mode": mode});
  } else {
    this.$class = 'J2SLetBlock';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.nodes = array2list(nodes);
        this.endloc = array2list(endloc);
        this.rec = rec;
        this.decls = array2list(decls);
        this.mode = typeof(mode) === 'symbol' ? mode.toString().slice(7,-1) : mode;
      } else {
        this.rec = true;
        this.mode = 'normal';
        Object.assign(this, loc);
       }
    }
  }
}
J2SLetBlock.prototype = new J2SBlock();
J2SLetBlock.prototype.duplicate = function(prop) {
   const o = new J2SLetBlock({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SIdStmt(loc, needBindExitBreak, id) {
  if (!new.target) {
    return new J2SIdStmt({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id});
  } else {
    this.$class = 'J2SIdStmt';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SIdStmt.prototype = new J2SStmt();
J2SIdStmt.prototype.duplicate = function(prop) {
   const o = new J2SIdStmt({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SSwitch(loc, needBindExitBreak, id, key, cases) {
  if (!new.target) {
    return new J2SSwitch({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "key": key, "cases": array2list(cases)});
  } else {
    this.$class = 'J2SSwitch';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this.key = key;
        this.cases = array2list(cases);
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SSwitch.prototype = new J2SIdStmt();
J2SSwitch.prototype.duplicate = function(prop) {
   const o = new J2SSwitch({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLoop(loc, needBindExitBreak, id, needBindExitContinue, body) {
  if (!new.target) {
    return new J2SLoop({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "needBindExitContinue": needBindExitContinue, "body": body});
  } else {
    this.$class = 'J2SLoop';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this["need-bind-exit-continue"] = needBindExitContinue;
        this.body = body;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        this.needBindExitContinue = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SLoop.prototype = new J2SIdStmt();
J2SLoop.prototype.duplicate = function(prop) {
   const o = new J2SLoop({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SFor(loc, needBindExitBreak, id, needBindExitContinue, body, init, test, incr) {
  if (!new.target) {
    return new J2SFor({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "needBindExitContinue": needBindExitContinue, "body": body, "init": init, "test": test, "incr": incr});
  } else {
    this.$class = 'J2SFor';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this["need-bind-exit-continue"] = needBindExitContinue;
        this.body = body;
        this.init = init;
        this.test = test;
        this.incr = incr;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        this.needBindExitContinue = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SFor.prototype = new J2SLoop();
J2SFor.prototype.duplicate = function(prop) {
   const o = new J2SFor({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SForIn(loc, needBindExitBreak, id, needBindExitContinue, body, op, lhs, obj) {
  if (!new.target) {
    return new J2SForIn({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "needBindExitContinue": needBindExitContinue, "body": body, "op": op, "lhs": lhs, "obj": obj});
  } else {
    this.$class = 'J2SForIn';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this["need-bind-exit-continue"] = needBindExitContinue;
        this.body = body;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
        this.lhs = lhs;
        this.obj = obj;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        this.needBindExitContinue = true;
        this.op = 'in';
        Object.assign(this, loc);
       }
    }
  }
}
J2SForIn.prototype = new J2SLoop();
J2SForIn.prototype.duplicate = function(prop) {
   const o = new J2SForIn({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SWhile(loc, needBindExitBreak, id, needBindExitContinue, body, test) {
  if (!new.target) {
    return new J2SWhile({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "needBindExitContinue": needBindExitContinue, "body": body, "test": test});
  } else {
    this.$class = 'J2SWhile';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this["need-bind-exit-continue"] = needBindExitContinue;
        this.body = body;
        this.test = test;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        this.needBindExitContinue = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SWhile.prototype = new J2SLoop();
J2SWhile.prototype.duplicate = function(prop) {
   const o = new J2SWhile({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDo(loc, needBindExitBreak, id, needBindExitContinue, body, test) {
  if (!new.target) {
    return new J2SDo({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "needBindExitContinue": needBindExitContinue, "body": body, "test": test});
  } else {
    this.$class = 'J2SDo';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this["need-bind-exit-continue"] = needBindExitContinue;
        this.body = body;
        this.test = test;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        this.needBindExitContinue = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDo.prototype = new J2SWhile();
J2SDo.prototype.duplicate = function(prop) {
   const o = new J2SDo({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLabel(loc, needBindExitBreak, id, body) {
  if (!new.target) {
    return new J2SLabel({"loc": array2list(loc), "needBindExitBreak": needBindExitBreak, "id": id, "body": body});
  } else {
    this.$class = 'J2SLabel';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this["need-bind-exit-break"] = needBindExitBreak;
        this.id = id;
        this.body = body;
      } else {
        this.needBindExitBreak = true;
        this.id = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SLabel.prototype = new J2SIdStmt();
J2SLabel.prototype.duplicate = function(prop) {
   const o = new J2SLabel({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SBreak(loc, target, id) {
  if (!new.target) {
    return new J2SBreak({"loc": array2list(loc), "target": target, "id": id});
  } else {
    this.$class = 'J2SBreak';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.target = target;
        this.id = id;
      } else {
        this.target = false;
        this.id = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SBreak.prototype = new J2SStmt();
J2SBreak.prototype.duplicate = function(prop) {
   const o = new J2SBreak({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SContinue(loc, target, id) {
  if (!new.target) {
    return new J2SContinue({"loc": array2list(loc), "target": target, "id": id});
  } else {
    this.$class = 'J2SContinue';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.target = target;
        this.id = id;
      } else {
        this.target = false;
        this.id = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SContinue.prototype = new J2SBreak();
J2SContinue.prototype.duplicate = function(prop) {
   const o = new J2SContinue({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SNop(loc) {
  if (!new.target) {
    return new J2SNop({"loc": array2list(loc)});
  } else {
    this.$class = 'J2SNop';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SNop.prototype = new J2SStmt();
J2SNop.prototype.duplicate = function(prop) {
   const o = new J2SNop({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCase(loc, expr, body, cascade) {
  if (!new.target) {
    return new J2SCase({"loc": array2list(loc), "expr": expr, "body": body, "cascade": cascade});
  } else {
    this.$class = 'J2SCase';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.expr = expr;
        this.body = body;
        this.cascade = cascade;
      } else {
        this.cascade = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCase.prototype = new J2SStmt();
J2SCase.prototype.duplicate = function(prop) {
   const o = new J2SCase({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDefault(loc, expr, body, cascade) {
  if (!new.target) {
    return new J2SDefault({"loc": array2list(loc), "expr": expr, "body": body, "cascade": cascade});
  } else {
    this.$class = 'J2SDefault';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.expr = expr;
        this.body = body;
        this.cascade = cascade;
      } else {
        this.cascade = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDefault.prototype = new J2SCase();
J2SDefault.prototype.duplicate = function(prop) {
   const o = new J2SDefault({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SBindExit(loc, type, hint, range, lbl, utype, stmt) {
  if (!new.target) {
    return new J2SBindExit({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lbl": lbl, "utype": utype, "stmt": stmt});
  } else {
    this.$class = 'J2SBindExit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lbl = lbl;
        this.utype = utype;
        this.stmt = stmt;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.utype = 'unknown';
        Object.assign(this, loc);
       }
    }
  }
}
J2SBindExit.prototype = new J2SExpr();
J2SBindExit.prototype.duplicate = function(prop) {
   const o = new J2SBindExit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SReturn(loc, exit, tail, from, expr) {
  if (!new.target) {
    return new J2SReturn({"loc": array2list(loc), "exit": exit, "tail": tail, "from": from, "expr": expr});
  } else {
    this.$class = 'J2SReturn';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.exit = exit;
        this.tail = tail;
        this.from = from;
        this.expr = expr;
      } else {
        this.exit = false;
        this.tail = true;
        this.from = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SReturn.prototype = new J2SStmt();
J2SReturn.prototype.duplicate = function(prop) {
   const o = new J2SReturn({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SReturnYield(loc, expr, generator, kont) {
  if (!new.target) {
    return new J2SReturnYield({"loc": array2list(loc), "expr": expr, "generator": generator, "kont": kont});
  } else {
    this.$class = 'J2SReturnYield';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.expr = expr;
        this.generator = generator;
        this.kont = kont;
      } else {
        this.generator = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SReturnYield.prototype = new J2SStmt();
J2SReturnYield.prototype.duplicate = function(prop) {
   const o = new J2SReturnYield({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SYield(loc, type, hint, range, expr, generator, $$await) {
  if (!new.target) {
    return new J2SYield({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "expr": expr, "generator": generator, "$$await": $$await});
  } else {
    this.$class = 'J2SYield';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.expr = expr;
        this.generator = generator;
        this.await = $$await;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.generator = false;
        this.$$await = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SYield.prototype = new J2SExpr();
J2SYield.prototype.duplicate = function(prop) {
   const o = new J2SYield({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SWith(loc, id, obj, block) {
  if (!new.target) {
    return new J2SWith({"loc": array2list(loc), "id": id, "obj": obj, "block": block});
  } else {
    this.$class = 'J2SWith';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.obj = obj;
        this.block = block;
      } else {
        this.id = '__with1004';
        Object.assign(this, loc);
       }
    }
  }
}
J2SWith.prototype = new J2SStmt();
J2SWith.prototype.duplicate = function(prop) {
   const o = new J2SWith({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SThrow(loc, expr) {
  if (!new.target) {
    return new J2SThrow({"loc": array2list(loc), "expr": expr});
  } else {
    this.$class = 'J2SThrow';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.expr = expr;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SThrow.prototype = new J2SStmt();
J2SThrow.prototype.duplicate = function(prop) {
   const o = new J2SThrow({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SFun(loc, type, hint, range, rtype, rutype, rrange, idthis, idgen, mode, decl, needBindExitReturn, newTarget, vararg, name, generator, optimize, thisp, argumentsp, params, constrsize, src, $$method, ismethodof, body) {
  if (!new.target) {
    return new J2SFun({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "rtype": rtype, "rutype": rutype, "rrange": rrange, "idthis": idthis, "idgen": idgen, "mode": mode, "decl": decl, "needBindExitReturn": needBindExitReturn, "newTarget": newTarget, "vararg": vararg, "name": name, "generator": generator, "optimize": optimize, "thisp": thisp, "argumentsp": argumentsp, "params": array2list(params), "constrsize": constrsize, "src": src, "$$method": $$method, "ismethodof": ismethodof, "body": body});
  } else {
    this.$class = 'J2SFun';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.rtype = rtype;
        this.rutype = rutype;
        this.rrange = rrange;
        this.idthis = idthis;
        this.idgen = idgen;
        this.mode = typeof(mode) === 'symbol' ? mode.toString().slice(7,-1) : mode;
        this.decl = decl;
        this["need-bind-exit-return"] = needBindExitReturn;
        this["new-target"] = typeof(newTarget) === 'symbol' ? newTarget.toString().slice(7,-1) : newTarget;
        this.vararg = vararg;
        this.name = typeof(name) === 'symbol' ? name.toString().slice(7,-1) : name;
        this.generator = generator;
        this.optimize = optimize;
        this.thisp = thisp;
        this.argumentsp = argumentsp;
        this.params = array2list(params);
        this.constrsize = constrsize;
        this.src = src;
        this.method = $$method;
        this.ismethodof = ismethodof;
        this.body = body;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.rtype = 'unknown';
        this.rutype = 'unknown';
        this.rrange = undefined;
        this.idthis = 'this';
        this.idgen = false;
        this.mode = 'normal';
        this.decl = false;
        this.needBindExitReturn = false;
        this.newTarget = 'unknown';
        this.vararg = false;
        this.generator = false;
        this.optimize = true;
        this.thisp = false;
        this.argumentsp = false;
        this.params = null;
        this.constrsize = 3;
        this.src = true;
        this.$$method = false;
        this.ismethodof = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SFun.prototype = new J2SExpr();
J2SFun.prototype.duplicate = function(prop) {
   const o = new J2SFun({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SSvc(loc, type, hint, range, rtype, rutype, rrange, idthis, idgen, mode, decl, needBindExitReturn, newTarget, vararg, name, generator, optimize, thisp, argumentsp, params, constrsize, src, $$method, ismethodof, body, init, path, register, $$import) {
  if (!new.target) {
    return new J2SSvc({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "rtype": rtype, "rutype": rutype, "rrange": rrange, "idthis": idthis, "idgen": idgen, "mode": mode, "decl": decl, "needBindExitReturn": needBindExitReturn, "newTarget": newTarget, "vararg": vararg, "name": name, "generator": generator, "optimize": optimize, "thisp": thisp, "argumentsp": argumentsp, "params": array2list(params), "constrsize": constrsize, "src": src, "$$method": $$method, "ismethodof": ismethodof, "body": body, "init": init, "path": path, "register": register, "$$import": $$import});
  } else {
    this.$class = 'J2SSvc';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.rtype = rtype;
        this.rutype = rutype;
        this.rrange = rrange;
        this.idthis = idthis;
        this.idgen = idgen;
        this.mode = typeof(mode) === 'symbol' ? mode.toString().slice(7,-1) : mode;
        this.decl = decl;
        this["need-bind-exit-return"] = needBindExitReturn;
        this["new-target"] = typeof(newTarget) === 'symbol' ? newTarget.toString().slice(7,-1) : newTarget;
        this.vararg = vararg;
        this.name = typeof(name) === 'symbol' ? name.toString().slice(7,-1) : name;
        this.generator = generator;
        this.optimize = optimize;
        this.thisp = thisp;
        this.argumentsp = argumentsp;
        this.params = array2list(params);
        this.constrsize = constrsize;
        this.src = src;
        this.method = $$method;
        this.ismethodof = ismethodof;
        this.body = body;
        this.init = init;
        this.path = path;
        this.register = register;
        this.import = $$import;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.rtype = 'unknown';
        this.rutype = 'unknown';
        this.rrange = undefined;
        this.idthis = 'this';
        this.idgen = false;
        this.mode = 'normal';
        this.decl = false;
        this.needBindExitReturn = false;
        this.newTarget = 'unknown';
        this.vararg = false;
        this.generator = false;
        this.optimize = true;
        this.thisp = false;
        this.argumentsp = false;
        this.params = null;
        this.constrsize = 3;
        this.src = true;
        this.$$method = false;
        this.ismethodof = false;
        this.path = false;
        this.register = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SSvc.prototype = new J2SFun();
J2SSvc.prototype.duplicate = function(prop) {
   const o = new J2SSvc({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SArrow(loc, type, hint, range, rtype, rutype, rrange, idthis, idgen, mode, decl, needBindExitReturn, newTarget, vararg, name, generator, optimize, thisp, argumentsp, params, constrsize, src, $$method, ismethodof, body) {
  if (!new.target) {
    return new J2SArrow({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "rtype": rtype, "rutype": rutype, "rrange": rrange, "idthis": idthis, "idgen": idgen, "mode": mode, "decl": decl, "needBindExitReturn": needBindExitReturn, "newTarget": newTarget, "vararg": vararg, "name": name, "generator": generator, "optimize": optimize, "thisp": thisp, "argumentsp": argumentsp, "params": array2list(params), "constrsize": constrsize, "src": src, "$$method": $$method, "ismethodof": ismethodof, "body": body});
  } else {
    this.$class = 'J2SArrow';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.rtype = rtype;
        this.rutype = rutype;
        this.rrange = rrange;
        this.idthis = idthis;
        this.idgen = idgen;
        this.mode = typeof(mode) === 'symbol' ? mode.toString().slice(7,-1) : mode;
        this.decl = decl;
        this["need-bind-exit-return"] = needBindExitReturn;
        this["new-target"] = typeof(newTarget) === 'symbol' ? newTarget.toString().slice(7,-1) : newTarget;
        this.vararg = vararg;
        this.name = typeof(name) === 'symbol' ? name.toString().slice(7,-1) : name;
        this.generator = generator;
        this.optimize = optimize;
        this.thisp = thisp;
        this.argumentsp = argumentsp;
        this.params = array2list(params);
        this.constrsize = constrsize;
        this.src = src;
        this.method = $$method;
        this.ismethodof = ismethodof;
        this.body = body;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.rtype = 'unknown';
        this.rutype = 'unknown';
        this.rrange = undefined;
        this.idthis = 'this';
        this.idgen = false;
        this.mode = 'normal';
        this.decl = false;
        this.needBindExitReturn = false;
        this.newTarget = 'unknown';
        this.vararg = false;
        this.generator = false;
        this.optimize = true;
        this.thisp = false;
        this.argumentsp = false;
        this.params = null;
        this.constrsize = 3;
        this.src = true;
        this.$$method = false;
        this.ismethodof = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SArrow.prototype = new J2SFun();
J2SArrow.prototype.duplicate = function(prop) {
   const o = new J2SArrow({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SMethod(loc, type, hint, range, $$function, $$method) {
  if (!new.target) {
    return new J2SMethod({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "$$function": $$function, "$$method": $$method});
  } else {
    this.$class = 'J2SMethod';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.function = $$function;
        this.method = $$method;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SMethod.prototype = new J2SExpr();
J2SMethod.prototype.duplicate = function(prop) {
   const o = new J2SMethod({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SClass(loc, type, hint, range, endloc, name, decl, $$super, src, elements, constrsize, cmap, needSuperCheck, needDeadZoneCheck, methods) {
  if (!new.target) {
    return new J2SClass({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "endloc": array2list(endloc), "name": name, "decl": decl, "$$super": $$super, "src": src, "elements": array2list(elements), "constrsize": constrsize, "cmap": cmap, "needSuperCheck": needSuperCheck, "needDeadZoneCheck": needDeadZoneCheck, "methods": methods});
  } else {
    this.$class = 'J2SClass';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.endloc = array2list(endloc);
        this.name = name;
        this.decl = decl;
        this.super = $$super;
        this.src = src;
        this.elements = array2list(elements);
        this.constrsize = constrsize;
        this.cmap = cmap;
        this["need-super-check"] = needSuperCheck;
        this["need-dead-zone-check"] = needDeadZoneCheck;
        this.methods = methods;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.decl = false;
        this.src = true;
        this.constrsize = 0;
        this.cmap = false;
        this.needSuperCheck = false;
        this.needDeadZoneCheck = false;
        this.methods = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SClass.prototype = new J2SExpr();
J2SClass.prototype.duplicate = function(prop) {
   const o = new J2SClass({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SRecord(loc, type, hint, range, endloc, name, decl, $$super, src, elements, constrsize, cmap, needSuperCheck, needDeadZoneCheck, methods) {
  if (!new.target) {
    return new J2SRecord({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "endloc": array2list(endloc), "name": name, "decl": decl, "$$super": $$super, "src": src, "elements": array2list(elements), "constrsize": constrsize, "cmap": cmap, "needSuperCheck": needSuperCheck, "needDeadZoneCheck": needDeadZoneCheck, "methods": methods});
  } else {
    this.$class = 'J2SRecord';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.endloc = array2list(endloc);
        this.name = name;
        this.decl = decl;
        this.super = $$super;
        this.src = src;
        this.elements = array2list(elements);
        this.constrsize = constrsize;
        this.cmap = cmap;
        this["need-super-check"] = needSuperCheck;
        this["need-dead-zone-check"] = needDeadZoneCheck;
        this.methods = methods;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.decl = false;
        this.src = true;
        this.constrsize = 0;
        this.cmap = false;
        this.needSuperCheck = false;
        this.needDeadZoneCheck = false;
        this.methods = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SRecord.prototype = new J2SClass();
J2SRecord.prototype.duplicate = function(prop) {
   const o = new J2SRecord({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SClassElement(loc, $$static, prop, type, clazz, index, rtwin, usage, hint) {
  if (!new.target) {
    return new J2SClassElement({"loc": array2list(loc), "$$static": $$static, "prop": prop, "type": type, "clazz": clazz, "index": index, "rtwin": rtwin, "usage": usage, "hint": array2list(hint)});
  } else {
    this.$class = 'J2SClassElement';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.static = $$static;
        this.prop = prop;
        this.type = type;
        this.clazz = clazz;
        this.index = index;
        this.rtwin = rtwin;
        this.usage = usage;
        this.hint = array2list(hint);
      } else {
        this.type = 'any';
        this.clazz = false;
        this.index = -1;
        this.rtwin = false;
        this.usage = ~~0;
        this.hint = null;
        Object.assign(this, loc);
       }
    }
  }
}
J2SClassElement.prototype = new J2SNode();
J2SClassElement.prototype.duplicate = function(prop) {
   const o = new J2SClassElement({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCatch(loc, param, body) {
  if (!new.target) {
    return new J2SCatch({"loc": array2list(loc), "param": param, "body": body});
  } else {
    this.$class = 'J2SCatch';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.param = param;
        this.body = body;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SCatch.prototype = new J2SStmt();
J2SCatch.prototype.duplicate = function(prop) {
   const o = new J2SCatch({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2STry(loc, body, $$catch, $$finally) {
  if (!new.target) {
    return new J2STry({"loc": array2list(loc), "body": body, "$$catch": $$catch, "$$finally": $$finally});
  } else {
    this.$class = 'J2STry';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.body = body;
        this.catch = $$catch;
        this.finally = $$finally;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2STry.prototype = new J2SStmt();
J2STry.prototype.duplicate = function(prop) {
   const o = new J2STry({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SPragma(loc, type, hint, range, lang, vars, vals, expr) {
  if (!new.target) {
    return new J2SPragma({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lang": lang, "vars": array2list(vars), "vals": array2list(vals), "expr": expr});
  } else {
    this.$class = 'J2SPragma';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lang = typeof(lang) === 'symbol' ? lang.toString().slice(7,-1) : lang;
        this.vars = array2list(vars);
        this.vals = array2list(vals);
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.lang = 'scheme';
        this.vars = null;
        this.vals = null;
        Object.assign(this, loc);
       }
    }
  }
}
J2SPragma.prototype = new J2SExpr();
J2SPragma.prototype.duplicate = function(prop) {
   const o = new J2SPragma({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SSequence(loc, type, hint, range, exprs) {
  if (!new.target) {
    return new J2SSequence({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "exprs": array2list(exprs)});
  } else {
    this.$class = 'J2SSequence';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.exprs = array2list(exprs);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SSequence.prototype = new J2SExpr();
J2SSequence.prototype.duplicate = function(prop) {
   const o = new J2SSequence({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SUnresolvedRef(loc, type, hint, range, cache, id) {
  if (!new.target) {
    return new J2SUnresolvedRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "cache": cache, "id": id});
  } else {
    this.$class = 'J2SUnresolvedRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.cache = cache;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.cache = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SUnresolvedRef.prototype = new J2SExpr();
J2SUnresolvedRef.prototype.duplicate = function(prop) {
   const o = new J2SUnresolvedRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SGlobalRef(loc, type, hint, range, cache, id, decl) {
  if (!new.target) {
    return new J2SGlobalRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "cache": cache, "id": id, "decl": decl});
  } else {
    this.$class = 'J2SGlobalRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.cache = cache;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.decl = decl;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.cache = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SGlobalRef.prototype = new J2SUnresolvedRef();
J2SGlobalRef.prototype.duplicate = function(prop) {
   const o = new J2SGlobalRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SRef(loc, type, hint, range, decl) {
  if (!new.target) {
    return new J2SRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl});
  } else {
    this.$class = 'J2SRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SRef.prototype = new J2SExpr();
J2SRef.prototype.duplicate = function(prop) {
   const o = new J2SRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SWithRef(loc, type, hint, range, id, withs, expr) {
  if (!new.target) {
    return new J2SWithRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "id": id, "withs": array2list(withs), "expr": expr});
  } else {
    this.$class = 'J2SWithRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.withs = array2list(withs);
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SWithRef.prototype = new J2SExpr();
J2SWithRef.prototype.duplicate = function(prop) {
   const o = new J2SWithRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SHopRef(loc, type, hint, range, id, rtype, module) {
  if (!new.target) {
    return new J2SHopRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "id": id, "rtype": rtype, "module": module});
  } else {
    this.$class = 'J2SHopRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.rtype = rtype;
        this.module = module;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.rtype = 'any';
        this.module = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SHopRef.prototype = new J2SExpr();
J2SHopRef.prototype.duplicate = function(prop) {
   const o = new J2SHopRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLetRef(loc, type, hint, range, decl) {
  if (!new.target) {
    return new J2SLetRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl});
  } else {
    this.$class = 'J2SLetRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SLetRef.prototype = new J2SRef();
J2SLetRef.prototype.duplicate = function(prop) {
   const o = new J2SLetRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SAref(loc, type, hint, range, decl, array, alen, amark, deps) {
  if (!new.target) {
    return new J2SAref({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl, "array": array, "alen": alen, "amark": amark, "deps": array2list(deps)});
  } else {
    this.$class = 'J2SAref';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
        this.array = array;
        this.alen = alen;
        this.amark = amark;
        this.deps = array2list(deps);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SAref.prototype = new J2SRef();
J2SAref.prototype.duplicate = function(prop) {
   const o = new J2SAref({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SKontRef(loc, type, hint, range, gen, index, id) {
  if (!new.target) {
    return new J2SKontRef({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "gen": gen, "index": index, "id": id});
  } else {
    this.$class = 'J2SKontRef';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.gen = gen;
        this.index = index;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SKontRef.prototype = new J2SExpr();
J2SKontRef.prototype.duplicate = function(prop) {
   const o = new J2SKontRef({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SThis(loc, type, hint, range, decl) {
  if (!new.target) {
    return new J2SThis({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl});
  } else {
    this.$class = 'J2SThis';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SThis.prototype = new J2SRef();
J2SThis.prototype.duplicate = function(prop) {
   const o = new J2SThis({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SSuper(loc, type, hint, range, decl, rtwinp, $$super, context) {
  if (!new.target) {
    return new J2SSuper({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl, "rtwinp": rtwinp, "$$super": $$super, "context": context});
  } else {
    this.$class = 'J2SSuper';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
        this.rtwinp = rtwinp;
        this.super = $$super;
        this.context = context;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.rtwinp = false;
        this.$$super = false;
        this.context = 'plain';
        Object.assign(this, loc);
       }
    }
  }
}
J2SSuper.prototype = new J2SRef();
J2SSuper.prototype.duplicate = function(prop) {
   const o = new J2SSuper({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCond(loc, type, hint, range, test, then, $$else) {
  if (!new.target) {
    return new J2SCond({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "test": test, "then": then, "$$else": $$else});
  } else {
    this.$class = 'J2SCond';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.test = test;
        this.then = then;
        this.else = $$else;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCond.prototype = new J2SExpr();
J2SCond.prototype.duplicate = function(prop) {
   const o = new J2SCond({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLiteral(loc, type, hint, range) {
  if (!new.target) {
    return new J2SLiteral({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range});
  } else {
    this.$class = 'J2SLiteral';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SLiteral.prototype = new J2SExpr();
J2SLiteral.prototype.duplicate = function(prop) {
   const o = new J2SLiteral({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SArrayAbsent(loc, type, hint, range) {
  if (!new.target) {
    return new J2SArrayAbsent({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range});
  } else {
    this.$class = 'J2SArrayAbsent';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SArrayAbsent.prototype = new J2SLiteral();
J2SArrayAbsent.prototype.duplicate = function(prop) {
   const o = new J2SArrayAbsent({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SNull(loc, type, hint, range) {
  if (!new.target) {
    return new J2SNull({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range});
  } else {
    this.$class = 'J2SNull';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SNull.prototype = new J2SLiteral();
J2SNull.prototype.duplicate = function(prop) {
   const o = new J2SNull({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SUndefined(loc, type, hint, range) {
  if (!new.target) {
    return new J2SUndefined({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range});
  } else {
    this.$class = 'J2SUndefined';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SUndefined.prototype = new J2SLiteral();
J2SUndefined.prototype.duplicate = function(prop) {
   const o = new J2SUndefined({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLiteralValue(loc, type, hint, range, val) {
  if (!new.target) {
    return new J2SLiteralValue({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val});
  } else {
    this.$class = 'J2SLiteralValue';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SLiteralValue.prototype = new J2SLiteral();
J2SLiteralValue.prototype.duplicate = function(prop) {
   const o = new J2SLiteralValue({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SNativeString(loc, type, hint, range, val) {
  if (!new.target) {
    return new J2SNativeString({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val});
  } else {
    this.$class = 'J2SNativeString';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SNativeString.prototype = new J2SLiteralValue();
J2SNativeString.prototype.duplicate = function(prop) {
   const o = new J2SNativeString({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SString(loc, type, hint, range, val, escape, $$private) {
  if (!new.target) {
    return new J2SString({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val, "escape": array2list(escape), "$$private": $$private});
  } else {
    this.$class = 'J2SString';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
        this.escape = array2list(escape);
        this.private = $$private;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.escape = null;
        this.$$private = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SString.prototype = new J2SLiteralValue();
J2SString.prototype.duplicate = function(prop) {
   const o = new J2SString({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SBool(loc, type, hint, range, val) {
  if (!new.target) {
    return new J2SBool({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val});
  } else {
    this.$class = 'J2SBool';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SBool.prototype = new J2SLiteralValue();
J2SBool.prototype.duplicate = function(prop) {
   const o = new J2SBool({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SNumber(loc, type, hint, range, val) {
  if (!new.target) {
    return new J2SNumber({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val});
  } else {
    this.$class = 'J2SNumber';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SNumber.prototype = new J2SLiteralValue();
J2SNumber.prototype.duplicate = function(prop) {
   const o = new J2SNumber({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SOctalNumber(loc, type, hint, range, val) {
  if (!new.target) {
    return new J2SOctalNumber({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val});
  } else {
    this.$class = 'J2SOctalNumber';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SOctalNumber.prototype = new J2SNumber();
J2SOctalNumber.prototype.duplicate = function(prop) {
   const o = new J2SOctalNumber({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SRegExp(loc, type, hint, range, val, flags, inline) {
  if (!new.target) {
    return new J2SRegExp({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val, "flags": flags, "inline": inline});
  } else {
    this.$class = 'J2SRegExp';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
        this.flags = flags;
        this.inline = inline;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.inline = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SRegExp.prototype = new J2SLiteralValue();
J2SRegExp.prototype.duplicate = function(prop) {
   const o = new J2SRegExp({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCmap(loc, type, hint, range, val, ctor) {
  if (!new.target) {
    return new J2SCmap({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "val": val, "ctor": ctor});
  } else {
    this.$class = 'J2SCmap';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.val = val;
        this.ctor = ctor;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.ctor = true;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCmap.prototype = new J2SLiteralValue();
J2SCmap.prototype.duplicate = function(prop) {
   const o = new J2SCmap({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SLiteralCnst(loc, type, hint, range, index, val) {
  if (!new.target) {
    return new J2SLiteralCnst({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "index": index, "val": val});
  } else {
    this.$class = 'J2SLiteralCnst';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.index = index;
        this.val = val;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SLiteralCnst.prototype = new J2SLiteral();
J2SLiteralCnst.prototype.duplicate = function(prop) {
   const o = new J2SLiteralCnst({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SArray(loc, type, hint, range, len, exprs) {
  if (!new.target) {
    return new J2SArray({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "len": len, "exprs": array2list(exprs)});
  } else {
    this.$class = 'J2SArray';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.len = len;
        this.exprs = array2list(exprs);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SArray.prototype = new J2SLiteral();
J2SArray.prototype.duplicate = function(prop) {
   const o = new J2SArray({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SSpread(loc, type, hint, range, stype, expr) {
  if (!new.target) {
    return new J2SSpread({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "stype": stype, "expr": expr});
  } else {
    this.$class = 'J2SSpread';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.stype = stype;
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SSpread.prototype = new J2SExpr();
J2SSpread.prototype.duplicate = function(prop) {
   const o = new J2SSpread({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2STemplate(loc, type, hint, range, exprs) {
  if (!new.target) {
    return new J2STemplate({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "exprs": array2list(exprs)});
  } else {
    this.$class = 'J2STemplate';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.exprs = array2list(exprs);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2STemplate.prototype = new J2SExpr();
J2STemplate.prototype.duplicate = function(prop) {
   const o = new J2STemplate({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SParen(loc, type, hint, range, expr) {
  if (!new.target) {
    return new J2SParen({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "expr": expr});
  } else {
    this.$class = 'J2SParen';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SParen.prototype = new J2SExpr();
J2SParen.prototype.duplicate = function(prop) {
   const o = new J2SParen({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SUnary(loc, type, hint, range, op, expr) {
  if (!new.target) {
    return new J2SUnary({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "op": op, "expr": expr});
  } else {
    this.$class = 'J2SUnary';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
        this.expr = expr;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SUnary.prototype = new J2SExpr();
J2SUnary.prototype.duplicate = function(prop) {
   const o = new J2SUnary({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SBinary(loc, type, hint, range, op, lhs, rhs) {
  if (!new.target) {
    return new J2SBinary({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "op": op, "lhs": lhs, "rhs": rhs});
  } else {
    this.$class = 'J2SBinary';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
        this.lhs = lhs;
        this.rhs = rhs;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SBinary.prototype = new J2SExpr();
J2SBinary.prototype.duplicate = function(prop) {
   const o = new J2SBinary({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SAssig(loc, type, hint, range, lhs, rhs) {
  if (!new.target) {
    return new J2SAssig({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lhs": lhs, "rhs": rhs});
  } else {
    this.$class = 'J2SAssig';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lhs = lhs;
        this.rhs = rhs;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SAssig.prototype = new J2SExpr();
J2SAssig.prototype.duplicate = function(prop) {
   const o = new J2SAssig({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SInit(loc, type, hint, range, lhs, rhs) {
  if (!new.target) {
    return new J2SInit({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lhs": lhs, "rhs": rhs});
  } else {
    this.$class = 'J2SInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lhs = lhs;
        this.rhs = rhs;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SInit.prototype = new J2SAssig();
J2SInit.prototype.duplicate = function(prop) {
   const o = new J2SInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SFunBinding(loc, type, hint, range, lhs, rhs) {
  if (!new.target) {
    return new J2SFunBinding({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lhs": lhs, "rhs": rhs});
  } else {
    this.$class = 'J2SFunBinding';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lhs = lhs;
        this.rhs = rhs;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SFunBinding.prototype = new J2SInit();
J2SFunBinding.prototype.duplicate = function(prop) {
   const o = new J2SFunBinding({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SPrefix(loc, type, hint, range, lhs, rhs, op) {
  if (!new.target) {
    return new J2SPrefix({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lhs": lhs, "rhs": rhs, "op": op});
  } else {
    this.$class = 'J2SPrefix';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lhs = lhs;
        this.rhs = rhs;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SPrefix.prototype = new J2SAssig();
J2SPrefix.prototype.duplicate = function(prop) {
   const o = new J2SPrefix({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SPostfix(loc, type, hint, range, lhs, rhs, op) {
  if (!new.target) {
    return new J2SPostfix({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lhs": lhs, "rhs": rhs, "op": op});
  } else {
    this.$class = 'J2SPostfix';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lhs = lhs;
        this.rhs = rhs;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SPostfix.prototype = new J2SAssig();
J2SPostfix.prototype.duplicate = function(prop) {
   const o = new J2SPostfix({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SAssigOp(loc, type, hint, range, lhs, rhs, op) {
  if (!new.target) {
    return new J2SAssigOp({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "lhs": lhs, "rhs": rhs, "op": op});
  } else {
    this.$class = 'J2SAssigOp';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.lhs = lhs;
        this.rhs = rhs;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SAssigOp.prototype = new J2SAssig();
J2SAssigOp.prototype.duplicate = function(prop) {
   const o = new J2SAssigOp({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SObjInit(loc, type, hint, range, inits, cmap, ronly) {
  if (!new.target) {
    return new J2SObjInit({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "inits": array2list(inits), "cmap": cmap, "ronly": ronly});
  } else {
    this.$class = 'J2SObjInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.inits = array2list(inits);
        this.cmap = cmap;
        this.ronly = ronly;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.cmap = false;
        this.ronly = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SObjInit.prototype = new J2SExpr();
J2SObjInit.prototype.duplicate = function(prop) {
   const o = new J2SObjInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SAccess(loc, type, hint, range, obj, field) {
  if (!new.target) {
    return new J2SAccess({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "obj": obj, "field": field});
  } else {
    this.$class = 'J2SAccess';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.obj = obj;
        this.field = field;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SAccess.prototype = new J2SExpr();
J2SAccess.prototype.duplicate = function(prop) {
   const o = new J2SAccess({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCacheCheck(loc, type, hint, range, prop, cache, owner, obj, fields) {
  if (!new.target) {
    return new J2SCacheCheck({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "prop": prop, "cache": cache, "owner": owner, "obj": obj, "fields": array2list(fields)});
  } else {
    this.$class = 'J2SCacheCheck';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.prop = typeof(prop) === 'symbol' ? prop.toString().slice(7,-1) : prop;
        this.cache = cache;
        this.owner = owner;
        this.obj = obj;
        this.fields = array2list(fields);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCacheCheck.prototype = new J2SExpr();
J2SCacheCheck.prototype.duplicate = function(prop) {
   const o = new J2SCacheCheck({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCacheUpdate(loc, type, hint, range, prop, cache, obj) {
  if (!new.target) {
    return new J2SCacheUpdate({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "prop": prop, "cache": cache, "obj": obj});
  } else {
    this.$class = 'J2SCacheUpdate';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.prop = typeof(prop) === 'symbol' ? prop.toString().slice(7,-1) : prop;
        this.cache = cache;
        this.obj = obj;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCacheUpdate.prototype = new J2SExpr();
J2SCacheUpdate.prototype.duplicate = function(prop) {
   const o = new J2SCacheUpdate({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SCall(loc, type, hint, range, profid, fun, protocol, thisargs, args) {
  if (!new.target) {
    return new J2SCall({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "profid": profid, "fun": fun, "protocol": protocol, "thisargs": array2list(thisargs), "args": array2list(args)});
  } else {
    this.$class = 'J2SCall';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.profid = profid;
        this.fun = fun;
        this.protocol = typeof(protocol) === 'symbol' ? protocol.toString().slice(7,-1) : protocol;
        this.thisargs = array2list(thisargs);
        this.args = array2list(args);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.profid = -1;
        this.protocol = 'direct';
        this.args = null;
        Object.assign(this, loc);
       }
    }
  }
}
J2SCall.prototype = new J2SExpr();
J2SCall.prototype.duplicate = function(prop) {
   const o = new J2SCall({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2STilde(loc, type, hint, range, stmt) {
  if (!new.target) {
    return new J2STilde({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "stmt": stmt});
  } else {
    this.$class = 'J2STilde';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.stmt = stmt;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2STilde.prototype = new J2SExpr();
J2STilde.prototype.duplicate = function(prop) {
   const o = new J2STilde({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDollar(loc, type, hint, range, node) {
  if (!new.target) {
    return new J2SDollar({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "node": node});
  } else {
    this.$class = 'J2SDollar';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.node = node;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDollar.prototype = new J2SExpr();
J2SDollar.prototype.duplicate = function(prop) {
   const o = new J2SDollar({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SNew(loc, type, hint, range, caches, clazz, protocol, args) {
  if (!new.target) {
    return new J2SNew({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "caches": caches, "clazz": clazz, "protocol": protocol, "args": array2list(args)});
  } else {
    this.$class = 'J2SNew';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.caches = caches;
        this.clazz = clazz;
        this.protocol = typeof(protocol) === 'symbol' ? protocol.toString().slice(7,-1) : protocol;
        this.args = array2list(args);
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.caches = null;
        this.protocol = 'direct';
        Object.assign(this, loc);
       }
    }
  }
}
J2SNew.prototype = new J2SExpr();
J2SNew.prototype.duplicate = function(prop) {
   const o = new J2SNew({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SPropertyInit(loc, name) {
  if (!new.target) {
    return new J2SPropertyInit({"loc": array2list(loc), "name": name});
  } else {
    this.$class = 'J2SPropertyInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.name = name;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SPropertyInit.prototype = new J2SNode();
J2SPropertyInit.prototype.duplicate = function(prop) {
   const o = new J2SPropertyInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDataPropertyInit(loc, name, val) {
  if (!new.target) {
    return new J2SDataPropertyInit({"loc": array2list(loc), "name": name, "val": val});
  } else {
    this.$class = 'J2SDataPropertyInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.name = name;
        this.val = val;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SDataPropertyInit.prototype = new J2SPropertyInit();
J2SDataPropertyInit.prototype.duplicate = function(prop) {
   const o = new J2SDataPropertyInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SMethodPropertyInit(loc, name, val, inlinecachevar) {
  if (!new.target) {
    return new J2SMethodPropertyInit({"loc": array2list(loc), "name": name, "val": val, "inlinecachevar": inlinecachevar});
  } else {
    this.$class = 'J2SMethodPropertyInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.name = name;
        this.val = val;
        this.inlinecachevar = inlinecachevar;
      } else {
        this.inlinecachevar = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SMethodPropertyInit.prototype = new J2SDataPropertyInit();
J2SMethodPropertyInit.prototype.duplicate = function(prop) {
   const o = new J2SMethodPropertyInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SAccessorPropertyInit(loc, name, get, set) {
  if (!new.target) {
    return new J2SAccessorPropertyInit({"loc": array2list(loc), "name": name, "get": get, "set": set});
  } else {
    this.$class = 'J2SAccessorPropertyInit';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.name = name;
        this.get = get;
        this.set = set;
      } else {
        this.get = false;
        this.set = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SAccessorPropertyInit.prototype = new J2SPropertyInit();
J2SAccessorPropertyInit.prototype.duplicate = function(prop) {
   const o = new J2SAccessorPropertyInit({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SKont(loc, type, hint, range, param, exn, body) {
  if (!new.target) {
    return new J2SKont({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "param": param, "exn": exn, "body": body});
  } else {
    this.$class = 'J2SKont';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.param = param;
        this.exn = exn;
        this.body = body;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SKont.prototype = new J2SExpr();
J2SKont.prototype.duplicate = function(prop) {
   const o = new J2SKont({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SOPTInitSeq(loc, nodes, ref, cmap, cache, offset, cnt) {
  if (!new.target) {
    return new J2SOPTInitSeq({"loc": array2list(loc), "nodes": array2list(nodes), "ref": ref, "cmap": cmap, "cache": cache, "offset": offset, "cnt": cnt});
  } else {
    this.$class = 'J2SOPTInitSeq';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.nodes = array2list(nodes);
        this.ref = ref;
        this.cmap = cmap;
        this.cache = cache;
        this.offset = typeof(offset) === 'symbol' ? offset.toString().slice(7,-1) : offset;
        this.cnt = typeof(cnt) === 'symbol' ? cnt.toString().slice(7,-1) : cnt;
      } else {
        this.cache = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SOPTInitSeq.prototype = new J2SSeq();
J2SOPTInitSeq.prototype.duplicate = function(prop) {
   const o = new J2SOPTInitSeq({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDProducer(loc, type, hint, range, decl, expr, size) {
  if (!new.target) {
    return new J2SDProducer({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl, "expr": expr, "size": size});
  } else {
    this.$class = 'J2SDProducer';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
        this.expr = expr;
        this.size = size;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDProducer.prototype = new J2SExpr();
J2SDProducer.prototype.duplicate = function(prop) {
   const o = new J2SDProducer({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SDConsumer(loc, type, hint, range, decl, expr, path) {
  if (!new.target) {
    return new J2SDConsumer({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "decl": decl, "expr": expr, "path": path});
  } else {
    this.$class = 'J2SDConsumer';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.decl = decl;
        this.expr = expr;
        this.path = path;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SDConsumer.prototype = new J2SExpr();
J2SDConsumer.prototype.duplicate = function(prop) {
   const o = new J2SDConsumer({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SExport(loc, id, alias) {
  if (!new.target) {
    return new J2SExport({"loc": array2list(loc), "id": id, "alias": alias});
  } else {
    this.$class = 'J2SExport';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.alias = typeof(alias) === 'symbol' ? alias.toString().slice(7,-1) : alias;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SExport.prototype = new J2SStmt();
J2SExport.prototype.duplicate = function(prop) {
   const o = new J2SExport({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SExportDefault(loc, id, alias, expr) {
  if (!new.target) {
    return new J2SExportDefault({"loc": array2list(loc), "id": id, "alias": alias, "expr": expr});
  } else {
    this.$class = 'J2SExportDefault';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.alias = typeof(alias) === 'symbol' ? alias.toString().slice(7,-1) : alias;
        this.expr = expr;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SExportDefault.prototype = new J2SExport();
J2SExportDefault.prototype.duplicate = function(prop) {
   const o = new J2SExportDefault({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SRedirect(loc, id, alias, $$export, $$import) {
  if (!new.target) {
    return new J2SRedirect({"loc": array2list(loc), "id": id, "alias": alias, "$$export": $$export, "$$import": $$import});
  } else {
    this.$class = 'J2SRedirect';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.alias = typeof(alias) === 'symbol' ? alias.toString().slice(7,-1) : alias;
        this.export = $$export;
        this.import = $$import;
      } else {
        this.$$export = false;
        this.$$import = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SRedirect.prototype = new J2SExport();
J2SRedirect.prototype.duplicate = function(prop) {
   const o = new J2SRedirect({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SRedirectNamespace(loc, id, alias, $$export, $$import) {
  if (!new.target) {
    return new J2SRedirectNamespace({"loc": array2list(loc), "id": id, "alias": alias, "$$export": $$export, "$$import": $$import});
  } else {
    this.$class = 'J2SRedirectNamespace';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.alias = typeof(alias) === 'symbol' ? alias.toString().slice(7,-1) : alias;
        this.export = $$export;
        this.import = $$import;
      } else {
        this.$$export = false;
        this.$$import = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SRedirectNamespace.prototype = new J2SRedirect();
J2SRedirectNamespace.prototype.duplicate = function(prop) {
   const o = new J2SRedirectNamespace({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SImportPath(loc, name, abspath, path, protocol, index, $$import) {
  if (!new.target) {
    return new J2SImportPath({"loc": loc, "name": name, "abspath": abspath, "path": path, "protocol": protocol, "index": index, "$$import": $$import});
  } else {
    this.$class = 'J2SImportPath';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.name = name;
        this.abspath = abspath;
        this.path = path;
        this.protocol = typeof(protocol) === 'symbol' ? protocol.toString().slice(7,-1) : protocol;
        this.index = index;
        this.import = $$import;
      } else {
        this.index = -9997;
        Object.assign(this, loc);
       }
    }
  }
}
J2SImportPath.prototype.duplicate = function(prop) {
   const o = new J2SImportPath({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SImport(loc, path, ipath, dollarpath, names, iprgm, lang, types) {
  if (!new.target) {
    return new J2SImport({"loc": array2list(loc), "path": path, "ipath": ipath, "dollarpath": dollarpath, "names": array2list(names), "iprgm": iprgm, "lang": lang, "types": types});
  } else {
    this.$class = 'J2SImport';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.path = path;
        this.ipath = ipath;
        this.dollarpath = dollarpath;
        this.names = array2list(names);
        this.iprgm = iprgm;
        this.lang = lang;
        this.types = types;
      } else {
        this.ipath = false;
        this.names = null;
        this.iprgm = false;
        this.lang = false;
        this.types = false;
        Object.assign(this, loc);
       }
    }
  }
}
J2SImport.prototype = new J2SStmt();
J2SImport.prototype.duplicate = function(prop) {
   const o = new J2SImport({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SImportName(loc, id, alias) {
  if (!new.target) {
    return new J2SImportName({"loc": loc, "id": id, "alias": alias});
  } else {
    this.$class = 'J2SImportName';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.alias = typeof(alias) === 'symbol' ? alias.toString().slice(7,-1) : alias;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
J2SImportName.prototype.duplicate = function(prop) {
   const o = new J2SImportName({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SImportNamespace(loc, type, hint, range, id, $$import) {
  if (!new.target) {
    return new J2SImportNamespace({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "id": id, "$$import": $$import});
  } else {
    this.$class = 'J2SImportNamespace';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.id = typeof(id) === 'symbol' ? id.toString().slice(7,-1) : id;
        this.import = $$import;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        Object.assign(this, loc);
       }
    }
  }
}
J2SImportNamespace.prototype = new J2SExpr();
J2SImportNamespace.prototype.duplicate = function(prop) {
   const o = new J2SImportNamespace({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function J2SImportDynamic(loc, type, hint, range, promise, base, path) {
  if (!new.target) {
    return new J2SImportDynamic({"loc": array2list(loc), "type": type, "hint": array2list(hint), "range": range, "promise": promise, "base": base, "path": path});
  } else {
    this.$class = 'J2SImportDynamic';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.type = type;
        this.hint = array2list(hint);
        this.range = range;
        this.promise = promise;
        this.base = base;
        this.path = path;
      } else {
        this.type = 'unknown';
        this.hint = null;
        this.range = undefined;
        this.promise = true;
        this.base = "/home/serrano/prgm/project/hop/hop/node_modules/hopc/node";
        Object.assign(this, loc);
       }
    }
  }
}
J2SImportDynamic.prototype = new J2SExpr();
J2SImportDynamic.prototype.duplicate = function(prop) {
   const o = new J2SImportDynamic({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsInterface(loc, id, decl, properties) {
  if (!new.target) {
    return new TsInterface({"loc": array2list(loc), "id": id, "decl": decl, "properties": array2list(properties)});
  } else {
    this.$class = 'TsInterface';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.id = id;
        this.decl = decl;
        this.properties = array2list(properties);
      } else {
        this.id = false;
        this.decl = false;
        Object.assign(this, loc);
       }
    }
  }
}
TsInterface.prototype = new J2SNode();
TsInterface.prototype.duplicate = function(prop) {
   const o = new TsInterface({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsInterfaceProperty(loc, name, optional, type) {
  if (!new.target) {
    return new TsInterfaceProperty({"loc": array2list(loc), "name": name, "optional": optional, "type": type});
  } else {
    this.$class = 'TsInterfaceProperty';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.name = name;
        this.optional = optional;
        this.type = type;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
TsInterfaceProperty.prototype = new J2SNode();
TsInterfaceProperty.prototype.duplicate = function(prop) {
   const o = new TsInterfaceProperty({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsInterfacePropertyName(loc, fakename, type) {
  if (!new.target) {
    return new TsInterfacePropertyName({"loc": loc, "fakename": fakename, "type": type});
  } else {
    this.$class = 'TsInterfacePropertyName';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.fakename = fakename;
        this.type = type;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
TsInterfacePropertyName.prototype.duplicate = function(prop) {
   const o = new TsInterfacePropertyName({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsType(loc) {
  if (!new.target) {
    return new TsType({"loc": array2list(loc)});
  } else {
    this.$class = 'TsType';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
TsType.prototype.duplicate = function(prop) {
   const o = new TsType({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsTypeArray(loc, of) {
  if (!new.target) {
    return new TsTypeArray({"loc": array2list(loc), "of": of});
  } else {
    this.$class = 'TsTypeArray';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.of = of;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
TsTypeArray.prototype = new TsType();
TsTypeArray.prototype.duplicate = function(prop) {
   const o = new TsTypeArray({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsTypeFunction(loc, range, domain) {
  if (!new.target) {
    return new TsTypeFunction({"loc": array2list(loc), "range": range, "domain": domain});
  } else {
    this.$class = 'TsTypeFunction';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.range = range;
        this.domain = domain;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
TsTypeFunction.prototype = new TsType();
TsTypeFunction.prototype.duplicate = function(prop) {
   const o = new TsTypeFunction({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export function TsTypeBinary(loc, op, lhs, rhs) {
  if (!new.target) {
    return new TsTypeBinary({"loc": array2list(loc), "op": op, "lhs": lhs, "rhs": rhs});
  } else {
    this.$class = 'TsTypeBinary';
    if (loc) {
      if (pairp(loc)) {
        this.loc = loc;
        this.op = typeof(op) === 'symbol' ? op.toString().slice(7,-1) : op;
        this.lhs = lhs;
        this.rhs = rhs;
      } else {
        Object.assign(this, loc);
       }
    }
  }
}
TsTypeBinary.prototype = new TsType();
TsTypeBinary.prototype.duplicate = function(prop) {
   const o = new TsTypeBinary({});
   Object.assign(o, this);
   Object.assign(o, prop);
   return o;
}

export let ast = { "J2SNode": J2SNode, "J2SStmt": J2SStmt, "J2SMeta": J2SMeta, "J2SSeq": J2SSeq, "J2SBlock": J2SBlock, "J2SProgram": J2SProgram, "J2SDecl": J2SDecl, "J2SDeclDestructure": J2SDeclDestructure, "J2SDeclRest": J2SDeclRest, "J2SDeclArguments": J2SDeclArguments, "J2SDeclInit": J2SDeclInit, "J2SDeclInitDestructure": J2SDeclInitDestructure, "J2SDeclFun": J2SDeclFun, "J2SDeclFunType": J2SDeclFunType, "J2SDeclSvc": J2SDeclSvc, "J2SDeclClass": J2SDeclClass, "J2SDeclExtern": J2SDeclExtern, "J2SDeclImport": J2SDeclImport, "J2SDeclInterface": J2SDeclInterface, "J2SExpr": J2SExpr, "J2SCast": J2SCast, "J2SCheck": J2SCheck, "J2SStmtExpr": J2SStmtExpr, "J2SIf": J2SIf, "J2SPrecache": J2SPrecache, "J2SIfIsRecord": J2SIfIsRecord, "J2SIfArgDefVal": J2SIfArgDefVal, "J2SVarDecls": J2SVarDecls, "J2SLetBlock": J2SLetBlock, "J2SIdStmt": J2SIdStmt, "J2SSwitch": J2SSwitch, "J2SLoop": J2SLoop, "J2SFor": J2SFor, "J2SForIn": J2SForIn, "J2SWhile": J2SWhile, "J2SDo": J2SDo, "J2SLabel": J2SLabel, "J2SBreak": J2SBreak, "J2SContinue": J2SContinue, "J2SNop": J2SNop, "J2SCase": J2SCase, "J2SDefault": J2SDefault, "J2SBindExit": J2SBindExit, "J2SReturn": J2SReturn, "J2SReturnYield": J2SReturnYield, "J2SYield": J2SYield, "J2SWith": J2SWith, "J2SThrow": J2SThrow, "J2SFun": J2SFun, "J2SSvc": J2SSvc, "J2SArrow": J2SArrow, "J2SMethod": J2SMethod, "J2SClass": J2SClass, "J2SRecord": J2SRecord, "J2SClassElement": J2SClassElement, "J2SCatch": J2SCatch, "J2STry": J2STry, "J2SPragma": J2SPragma, "J2SSequence": J2SSequence, "J2SUnresolvedRef": J2SUnresolvedRef, "J2SGlobalRef": J2SGlobalRef, "J2SRef": J2SRef, "J2SWithRef": J2SWithRef, "J2SHopRef": J2SHopRef, "J2SLetRef": J2SLetRef, "J2SAref": J2SAref, "J2SKontRef": J2SKontRef, "J2SThis": J2SThis, "J2SSuper": J2SSuper, "J2SCond": J2SCond, "J2SLiteral": J2SLiteral, "J2SArrayAbsent": J2SArrayAbsent, "J2SNull": J2SNull, "J2SUndefined": J2SUndefined, "J2SLiteralValue": J2SLiteralValue, "J2SNativeString": J2SNativeString, "J2SString": J2SString, "J2SBool": J2SBool, "J2SNumber": J2SNumber, "J2SOctalNumber": J2SOctalNumber, "J2SRegExp": J2SRegExp, "J2SCmap": J2SCmap, "J2SLiteralCnst": J2SLiteralCnst, "J2SArray": J2SArray, "J2SSpread": J2SSpread, "J2STemplate": J2STemplate, "J2SParen": J2SParen, "J2SUnary": J2SUnary, "J2SBinary": J2SBinary, "J2SAssig": J2SAssig, "J2SInit": J2SInit, "J2SFunBinding": J2SFunBinding, "J2SPrefix": J2SPrefix, "J2SPostfix": J2SPostfix, "J2SAssigOp": J2SAssigOp, "J2SObjInit": J2SObjInit, "J2SAccess": J2SAccess, "J2SCacheCheck": J2SCacheCheck, "J2SCacheUpdate": J2SCacheUpdate, "J2SCall": J2SCall, "J2STilde": J2STilde, "J2SDollar": J2SDollar, "J2SNew": J2SNew, "J2SPropertyInit": J2SPropertyInit, "J2SDataPropertyInit": J2SDataPropertyInit, "J2SMethodPropertyInit": J2SMethodPropertyInit, "J2SAccessorPropertyInit": J2SAccessorPropertyInit, "J2SKont": J2SKont, "J2SOPTInitSeq": J2SOPTInitSeq, "J2SDProducer": J2SDProducer, "J2SDConsumer": J2SDConsumer, "J2SExport": J2SExport, "J2SExportDefault": J2SExportDefault, "J2SRedirect": J2SRedirect, "J2SRedirectNamespace": J2SRedirectNamespace, "J2SImportPath": J2SImportPath, "J2SImport": J2SImport, "J2SImportName": J2SImportName, "J2SImportNamespace": J2SImportNamespace, "J2SImportDynamic": J2SImportDynamic, "TsInterface": TsInterface, "TsInterfaceProperty": TsInterfaceProperty, "TsInterfacePropertyName": TsInterfacePropertyName, "TsType": TsType, "TsTypeArray": TsTypeArray, "TsTypeFunction": TsTypeFunction, "TsTypeBinary": TsTypeBinary
}
/*---------------------------------------------------------------------*/
/*    Definitions to be concatenated to ast.mjs when generated.        */
/*---------------------------------------------------------------------*/

/*---------------------------------------------------------------------*/
/*    isNative ...                                                     */
/*---------------------------------------------------------------------*/
function isNative() {
   return false;
}

/*---------------------------------------------------------------------*/
/*    wrap ...                                                         */
/*---------------------------------------------------------------------*/
export function wrap(o) {
   throw new Error(`Node backend cannot wrap ast nodes -- ${o}`);
}

/*---------------------------------------------------------------------*/
/*    registerWrapper ...                                              */
/*---------------------------------------------------------------------*/
export function registerWrapper(name, clazz) {
   // Hop backend specific
}

/*---------------------------------------------------------------------*/
/*    toString ...                                                     */
/*---------------------------------------------------------------------*/
J2SNode.prototype.toString = function() {
   return `<${this.clazz}>`;
}

/*---------------------------------------------------------------------*/
/*    j2sLetp ...                                                      */
/*---------------------------------------------------------------------*/
export function j2sLetp(decl) {
   switch (decl.binder) {
      case "let":
      case "let-opt":
      case "let-forin":
	 return true;
      case "var":
      case "param":
      case "record":
      case "export":
	 return false;
      default:
	 throw `j2sLetp: wrong binder "${decl.binder}"`;
   }
}
ast.j2sLetp = j2sLetp;

/*---------------------------------------------------------------------*/
/*    j2sVarp ...                                                      */
/*---------------------------------------------------------------------*/
export function j2sVarp(decl) {
   switch (decl.binder) {
      case "var":
	 return true;
      case "let":
      case "let-opt":
      case "let-forin":
	 return true;
      case "var":
      case "param":
      case "record":
      case "export":
	 return false;
      default:
	 throw `j2sVarp: wrong binder "${decl.binder}"`;
   }
}
ast.j2sVarp = j2sVarp;

/*---------------------------------------------------------------------*/
/*    j2sConstp ...                                                    */
/*---------------------------------------------------------------------*/
export function j2sConstp(decl) {
   if (decl.writable) {
      return false;
   } else {
      switch (decl.binder) {
	 case "let":
	 case "let-opt":
	 case "let-forin":
	 case "export":
	    return true;
	 case "var":
	 case "param":
	 case "record":
	    return false;
	 default:
	    throw `j2sConstp: wrong binder "${decl.binder}"`;
      }
   }
}
ast.j2sConstp = j2sConstp;

/*---------------------------------------------------------------------*/
/*    j2sfunExpressionp ...                                            */
/*---------------------------------------------------------------------*/
export function j2sfunExpressionp(fun) {
   if (fun.decl instanceof J2SDeclFun) {
      return fun.decl.expression;
   } else {
      return false;
   }
}
ast.j2sfunExpressionp = j2sfunExpressionp;

/*---------------------------------------------------------------------*/
/*    hopcWalk ...                                                     */
/*---------------------------------------------------------------------*/
function walk(proc) {
   proc(this);
   for (let k in this) {
      const p = this[k];
      if (p instanceof Object) {
	 if ("hopcWalk" in p) {
	    p.hopcWalk(proc);
	 } else if (pairp(p)) {
	    forEach(e => {
	       if ("hopcWalk" in e) {
		  e.hopcWalk(proc);
	       }
	    }, p);
	 }
      }
   }
}

J2SNode.prototype.hopcWalk = walk;
J2SImportPath.prototype.hopcWalk = walk;
J2SImportName.prototype.hopcWalk = walk;

