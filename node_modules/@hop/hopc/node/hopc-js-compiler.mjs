/*=====================================================================*/
/*    .../hop/hop/node_modules/hopc/node/hopc-js-compiler.mjs          */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Wed Oct 25 08:13:33 2023                          */
/*    Last change :  Fri May 31 20:09:37 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    Plain Hopc compiler                                              */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    es6 module                                                       */
/*---------------------------------------------------------------------*/
import { Config } from "./config.mjs";
import { j2sParser } from "./parser.mjs";
import { openInputFile, openInputString } from "./utils.mjs";
import { cons, list } from "./list.mjs";
import { $ioParseError } from "./error.mjs";
import { J2SNode } from "./ast.mjs";
import { generate } from "./generate.mjs";
import { writeFile } from 'node:fs/promises';
import { dirname } from "path";

export { Parser, parse, parseString, compile, compileErrorHandler };

/*---------------------------------------------------------------------*/
/*    keywords                                                         */
/*---------------------------------------------------------------------*/
const keywordsSimple =
   ["DOT", "DOTS", "SEMICOLON", "COMMA", "LBRACE", "RBRACE", "LPAREN",
    "RPAREN", "ID", "DOLLAR", "LBRACKET", "RBRACKET", "OR", "BIT_OR",
    "STRING", "await", "break", "case", "catch", "const", "continue",
    "debugger", "default", "delete", "do", "else", "false", "finally",
    "for", "function", "if", "in", "instanceof", "let", "new", "null",
    "return", "switch", "this", "throw", "true", "try", "typeof", "var",
    "void", "while", "with", "yield", "class", "extends", "super",
    "static"];

const keywordsValue =
   [{key: "ELSE", val: "else"}, {key: "COLUMN", val: ":"},
    {key: "EGAL", val: "="}, {key: "NOTEGAL", val: "!="},
    {key: "EGALEGAL", val: "=="}, {key: "NOTEGALEGAL", val: "!=="},
    {key: "EGALEGALEGAL", val: "==="}, 
    {key: "LT", val: "<"}, {key: "GT", val: ">"},
    {key: "LE", val: "<="}, {key: "GE", val: ">="},
    {key: "PLUS", val: "+"}, {key: "MINUS", val: "-"},
    {key: "MUL", val: "*"}, {key: "PERCENT", val: "%"},
    {key: "PLUSPLUS", val: "++"}, {key: "MINUSMINUS", val: "--"}, 
    {key: "SHIFTL", val: "<<"}, {key: "SHIFTR", val: ">>"},
    {key: "USHIFTR", val: ">>>"}, {key: "AMP", val: "&"},
    {key: "HAT", val: "^"}, {key: "BANG", val: "!"},
    {key: "TILDE", val: "~"}, {key: "AND", val: "&&"},
    {key: "PLUSEGAL", val: "+="}, {key: "MINUSEGAL", val: "-="},
    {key: "MULEGAL", val: "*="}, {key: "PERCENTEGAL", val: "%="},
    {key: "SHIFTLEGAL", val: "<<="}, {key: "SHIFTREGAL", val: ">>="},
    {key: "USHIFTREGAL", val: ">>>="}, {key: "AMPEGAL", val: "&="},
    {key: "HATEGAL", val: "^="}, {key: "DIVEGAL", val: "/="},
    {key: "DIV", val: "/"}, {key: "QUESTIONMARK", val: "?"},
    {key: "LARROW", val: "=>"}];

const typescriptValue =
   [{key: "AS", val: "as"},
    {key: "INTERFACE", val: "interface"},
    {key: "TYPE", val: "type"}];
			     
/*---------------------------------------------------------------------*/
/*    Parser ...                                                       */
/*---------------------------------------------------------------------*/
class Parser {
   ip;
   controller = false;
   data = null;

   constructor() {
      keywordsSimple.forEach(id => this[id] = id);
      keywordsValue.forEach(({key, val}) => this[key] = val);
      typescriptValue.forEach(({key, val}) => this[key] = val);
   }

   parse(path, conf = {}) {
      const ip = openInputFile(path.toString());
      const co = Object.assign({ parser: "program", "no-dialect": true }, conf);
      
      this.controller = false;
      return j2sParser(ip, new Config(co), this.data)
   }

   parseString(val, conf = {}) {
      const ip = openInputString(val);
      const co = Object.assign({ parser: "module", "no-dialect": true }, conf);

      this.controller = false;
      return j2sParser(ip, new Config(co), this.data);
   }

   plugins() {
      return this.data;
   }
   
   addPlugin(key, parser) {
      const plug = cons(key, this.pluginParse(parser));
      this.data = cons(plug, this.data);
   }

   removePlugin(key) {
      this.data = this.data.filter(e => car(e) !== key);
   }

   pluginParse(parser) {
      return (tok, decl, conf, ctrl) => {
	 this.controller = ctrl;
	 return parser.call(this, jsToken(tok), decl, conf);
      }
   }

   peekToken(token) {
      if (this.controller) {
	 return jsToken(this.controller[2]());
      } else {
	 throw "peekToken: detached plugin parser";
      }
   }

   consumeToken(token) {
      if (this.controller) {
	 return jsToken(this.controller[3](token.toString()));
      } else {
	 throw "consumeToken: detached plugin parser";
      }
   }
   
   consumeAny(token) {
      if (this.controller) {
	 return jsToken(this.controller[4]());
      } else {
	 throw "consumeAny: detached plugin parser";
      }
   }
   
   parseExpression() {
      if (this.controller) {
	 return this.controller[5](false, false, this.data);
      } else {
	 throw "parseExpression: detached plugin parser";
      }
   }

   parsePrimary() {
      if (this.controller) {
	 return this.controller[0](false, false, this.data);
      } else {
	 throw "parsePrimary: detached plugin parser";
      }
   }

   parsePrimaryDollar() {
      if (this.controller) {
	 return this.controller[1](false, false, this.data);
      } else {
	 throw "parsePrimaryDollar: detached plugin parser";
      }
   }

   parseCondExpression() {
      if (this.controller) {
	 return this.controller[8](false, false, true, this.data);
      } else {
	 throw "parseCondExpression: detached plugin parser";
      }
   }

   parseAssigExpression() {
      if (this.controller) {
	 return this.controller[10](false, false, true, this.data);
      } else {
	 throw "parseAssigExpression: detached plugin parser";
      }
   }

   parseDollarExpression() {
      if (this.controller) {
	 return this.controller[9](this.data);
      } else {
	 throw "parseDollarExpression: detached plugin parser";
      }
   }

   parseStatement() {
      if (this.controller) {
	 return this.controller[6](this.data);
      } else {
	 throw "parseStatement: detached plugin parser";
      }
   }

   parseBlock() {
      if (this.controller) {
	 return this.controller[7](this.data);
      } else {
	 throw "parseBlock: detached plugin parser";
      }
   }
}

/*---------------------------------------------------------------------*/
/*    jsToken ...                                                      */
/*---------------------------------------------------------------------*/
function jsToken(tok) {
   // backward compatibility
   tok.location = list("at", tok.loc.filename, tok.loc.offset);
   return tok;
}

/*---------------------------------------------------------------------*/
/*    language compiler (pre-processor)                                */
/*---------------------------------------------------------------------*/
const parser = new Parser();

const parse = parser.parse.bind(parser);
const parseString = parser.parseString.bind(parser);

/*---------------------------------------------------------------------*/
/*    isString ...                                                     */
/*---------------------------------------------------------------------*/
function isString(node) {
   if (node.clazz === "J2SStmtExpr") {
      const expr = node.expr;
      return expr.clazz === "J2SString";
   } else {
      return false;
   }
}

/*---------------------------------------------------------------------*/
/*    addHopImport ...                                                 */
/*---------------------------------------------------------------------*/
function addHopImport(prog, from) {
   if (from) {
      let nodes = prog.nodes;
      let prev = null;
      const imp = parseString("import { A, ABBR, ACRONYM, ADDRESS, APPLET, AREA, ARTICLE, AUDIO, B, BASE, BDI, BDO, BIG, BLOCKQUOTE, BODY, BR, BUTTON, CANVAS, CAPTION, CENTER, CITE, CODE, COL, COLGROUP, DATALIST, DD, DEL, DETAILS, DFN, DIR, DIV, DL, DT, EM, EMBED, FIELDSET, FIGURE, FIGCAPTION, FONT, FOOTER, FORM, FRAME, FRAMESET, H1, H2, H3, H4, H5, H6, HEAD, HEADER, HGROUP, HR, I, IFRAME, IMG, INPUT, INS, ISINDEX, KBD, LABEL, LEGEND, LI, LINK, MAIN, MAP, MARQUEE, MENU, MENUITEM, META, METER, NAV, NOFRAMES, NOSCRIPT, OBJECT, OL, OPTGROUP, OPTION, P, PARAM, PRE, PROGRESS, Q, S, SAMP, SCRIPT, SECTION, SELECT, SMALL, SOURCE, SPAN, STRIKE, STRONG, STYLE, SUB, SUMMARY, SUP, TABLE, TBODY, TD, TEXTAREA, TFOOT, TH, THEAD, TIME, TITLE, TR, TRACK, TT, U, UL, VAR, HTML, TILDE, DOLLAR, SVG, VIDEO, XmlElement, HtmlElement, Tilde } from \""
	 + from + "\"");

      // patch the location of the manually inserted ast
      imp.hopcWalk(n => n.loc = prog.loc);
      
      while (isString(nodes.car)) {
	 prev = nodes;
	 nodes = nodes.cdr;
      }

      if (prev) {
	 prev.cdr = { car: imp, cdr: prev.cdr }
      } else {
	 prog.nodes = { car: imp, cdr: prog.nodes }
      }
   }
   
   return prog;
}

/*---------------------------------------------------------------------*/
/*    HopProgram ...                                                   */
/*---------------------------------------------------------------------*/
class HopProgram {
   #source = false;
   #fragment = undefined;
   
   constructor(source, fragment) {
      this.#source = source;
      this.#fragment = fragment;
   }

   output(target) {
      const prgm = this.#fragment.toString();

      if (!target) {
	 return new Promise((res, rej) => { console.log(prgm); res(true) });
      } else {
	 const tag = `\n//# sourceMappingURL=${target}.map\n`;

	 return writeFile(target, prgm + tag);
      }
   }

   sourcemap(target) {
      const sm = {
	 version: 3,
	 file: target,
	 sources: [ this.#source ],
	 names: [],
	 mappings: this.#fragment.mappings(this.#source, target)
      }
      return writeFile(target + ".map", JSON.stringify(sm));
   }
}

/*---------------------------------------------------------------------*/
/*    compileErrorHandler ...                                          */
/*---------------------------------------------------------------------*/
function compileErrorHandler(err) {
   if (err && err.obj && err.obj.loc?.filename) {
      $ioParseError({
	 "fname": err.obj.loc.filename,
	 "location": err.obj.loc?.offset ?? -1,
	 "msg": "Parse error",
	 "message": err.msg || err.message,
	 "obj": err.obj,
	 forceexit: true
      });
      throw "syntax error.";
   } else if (err && err?.fname && (typeof err?.location === "number")) {
      $ioParseError({
	 "fname": err.fname,
	 "location": err.location,
	 "message": err.msg || err.message,
	 "obj": err.obj,
	 forceexit: true
      });
      throw "syntax error.";
   } else if (err && (typeof err?.location === "number")) {
      $ioParseError({
	 "fname": err.location.filename,
	 "location": err.location.pos || err.location.offset,
	 "msg": "Parse error",
	 "message": err.msg || err.message,
	 "obj": err.obj,
	 forceexit: true
      });
      throw "syntax error.";
   } else {
      throw err;
   }
}
    
/*---------------------------------------------------------------------*/
/*    compile ...                                                      */
/*---------------------------------------------------------------------*/
async function compile(source, target, conf = {}) {
   try {
      const ast = parse(source, conf, {});
      const prog = new HopProgram(source, generate(addHopImport(ast, conf.importFrom), conf));
      await prog.output(target);
      await prog.sourcemap(target);
      return target;
   } catch(err) {
      compileErrorHandler(err);
   }
}
