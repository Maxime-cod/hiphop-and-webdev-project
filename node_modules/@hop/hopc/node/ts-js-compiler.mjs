/*=====================================================================*/
/*    .../hop/hop/node_modules/hopc/node/ts-js-compiler.mjs            */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Feb 13 09:30:38 2024                          */
/*    Last change :  Sat Mar 23 06:51:56 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Simple typescript compiler using the TSC API                     */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    module                                                           */
/*---------------------------------------------------------------------*/
import { default as ts } from "typescript";
import * as path from "node:path";
import { compileErrorLineCol, compileErrorPoint } from "./error.mjs";
import { existsSync, readFileSync, writeFileSync, writeSync } from "node:fs";
import { load as loadSourceMap, encode, remap } from "./sourcemap.mjs";

export { compile };

/*---------------------------------------------------------------------*/
/*    global options                                                   */
/*---------------------------------------------------------------------*/
const HOPMODULESDIR = import.meta.url.replace(/^file:\/\//, "");

const options = {
   pretty: false,
   allowJS: true,
   target: ts.ScriptTarget.NodeNext,
   module: ts.ModuleKind.NodeNext,
   autorequire: true,
   moduleResolution: ts.ModuleResolutionKind.NodeNext,
   experimentalDecorators: true,
   allowSyntheticDefaultImports: true,
   sourceMap: true
};

/*---------------------------------------------------------------------*/
/*    sourceMap ...                                                    */
/*---------------------------------------------------------------------*/
function sourceMap(filename, line, col) {
   const buf = readFileSync(filename).toString();
   const m = buf.match(/^\/\/# sourceMappingURL=([^\n]+)$/m);

   if (m && existsSync(m[1])) {
      const { sources, lines } = loadSourceMap(m[1]);
      if (line >= 0 && line < lines.length) {
	 const seg = lines[line].find(s => s.tgtCol >= col - 1);
	 if (seg) {
	    // sourcemap line numbers start at 0 but for error report
	    // we need them to start at 1
	    return { file: sources[seg.srcIndex], lnum: seg.srcLine + 1, col: seg.srcCol };
	 }
      }
      return { file: false, lnum: 0, col: 0 };
   } else {
      return { file: filename, lnum: line + 1, col: col };
   }
   
}

/*---------------------------------------------------------------------*/
/*    reSourceMap ...                                                  */
/*    -------------------------------------------------------------    */
/*    TypeScript has generated a source map file that maps the         */
/*    .js to the .ts file. This function "remaps" to the orginal .ts   */
/*    file.                                                            */
/*---------------------------------------------------------------------*/
function reSourceMap(target, filename) {
   const buf = readFileSync(filename).toString();
   const m = buf.match(/^\/\/# sourceMappingURL=([^\n]+)$/m);

   if (m && existsSync(m[1])) {
      writeFileSync(target, JSON.stringify(remap(target, m[1])));
   }
}

/*---------------------------------------------------------------------*/
/*    compile ...                                                      */
/*---------------------------------------------------------------------*/
async function compile(source) {
   try {
      const program = ts.createProgram([source], options);
      const emitResult = program.emit();
      const allDiagnostics = ts
	 .getPreEmitDiagnostics(program)
	 .concat(emitResult.diagnostics);

      allDiagnostics.forEach(diagnostic => {
	 let msg =
	    ts.flattenDiagnosticMessageText(diagnostic.messageText, "\n");
	 if (diagnostic.file) {
	    let { line, character: char } =
	       ts.getLineAndCharacterOfPosition(diagnostic.file, diagnostic.start);
	    const filename = diagnostic.file.fileName;

/* 	    console.error(">==================================");      */
/* 	    console.error(">>> MSG=", msg);                            */
/* 	    console.error("filename=", filename);                      */
/* 	    console.error("source=", source);                          */
/* 	    console.error("line=", line, "char=", char);               */

	    const { file, lnum, col } = sourceMap(filename, line, char);
/* 	    console.error("lnum=", lnum, "col=", col);                 */

	    if (file) {
	       compileErrorLineCol(file, lnum, col, msg);
	    } else {
	       compileErrorLineCol(filename, line + 1, char, msg);
	    }
/* 	    console.error("<==================================");      */
	    setTimeout(() => process.exit(1));
	 } else {
	    throw new TypeError(msg);
	 }
      });
      
      if (emitResult.emitSkipped || allDiagnostics.length > 0) {
	 process.exit(1);
	 return false;
      } else {
	 const target = source.replace(/\.ts$/, ".js");
	 const targetsm = target + ".map";

	 if (existsSync(targetsm)) {
	    reSourceMap(targetsm, source);
	 }
	 
	 return target;
      }
   } catch(e) {
      console.error("e=", e);
      process.exit(1);
      return false;
   }
}
