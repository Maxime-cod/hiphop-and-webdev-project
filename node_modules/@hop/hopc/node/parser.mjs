/*=====================================================================*/
/*    .../project/hop/hop/node_modules/hopc/node/parser-module.js      */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Mar 26 07:53:55 2024                          */
/*    Last change :  Fri Jul 19 11:34:39 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Hop parser (generated from js2scheme/parser.scm)                 */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { configGet, configAdd, confMaxInt, confMinInt } from "./config.mjs";
import { makeToken, tokenp, tokenType, tokenValue, tokenLoc,
	 queueInit, queueEmptyp, queuePush, queuePop, queuePeek } from "./token.mjs";
import { nullp, pairp, cons, cons_, car, cdr, cadr, lastPair, list, length,
	 reverse$, reverse, append, assq,
	 map, map$, forEach, find, filter, filterMap, appendMap, any,
	 iota } from "./list.mjs";
import { inputPortName, inputPortPosition, symbolp, symboltostring,
	 symboltostring$, fileSeparator, fileNameCanonicalize$, pwd,
	 makeFileName, format, memqArray,
	 flonump, bignump, procedurep, fixnumtollong, substring,
	 stringPrefixp, stringIndexRight, stringtosymbol, stringUpcase,
	 gensym,
	 declUsageHasp, symbolAppend } from "./utils.mjs";
import { makeLoc, Location, read_rp, readLine, locFilename, locOffset } from "./reader.mjs";
import { j2sReservedIdp, j2sLexer, j2sRegexLexer, j2sTemplateLexer, j2sEscapeJsString } from "./lexer.mjs";
import { htmlParser } from "./html.mjs";
import { $ioParseError } from "./error.mjs";
import { J2SNode, J2SProgram, J2SBlock,
	 J2SImport, J2SImportName, J2SImportDynamic,
	 J2SExport, J2SExportDefault,
	 J2SRedirect, J2SRedirectNamespace,
	 J2SStmt, J2SStmtExpr, J2SNop,
	 J2SVarDecls, J2SDecl, J2SDeclDestructure,
	 J2SDeclInit, J2SDeclInitDestructure, J2SDeclRest,
	 J2SExpr, J2SParen, J2SSequence,
	 J2SAccess, J2SSeq, J2SCond, J2SObjInit,
	 J2SFun, J2SArrow, J2SDeclFun, J2SSvc, J2SDeclSvc, J2SReturn, J2SYield, 
	 J2SIf, J2SIfArgDefVal, J2SSwitch, J2SCase, J2SDefault,
	 J2SCatch, J2STry, J2SThrow,
	 J2SFor, J2SForIn, J2SWhile, J2SDo, J2SBreak, J2SContinue,
	 J2SCall, J2SNew, 
	 J2SString, J2SUndefined, J2SNull, J2SBool, J2SNumber, J2SOctalNumber,
	 J2SRegExp, J2SArray, J2SArrayAbsent,
	 J2SUnresolvedRef, J2SHopRef, J2SRef,
	 J2SPropertyInit, J2SDataPropertyInit, J2SAccessorPropertyInit, J2SMethodPropertyInit,
	 J2SSpread, J2SDConsumer, J2SDProducer,
	 J2SAssig, J2SAssigOp, J2SPrefix, J2SPostfix,
	 J2SBindExit, J2SUnary, J2SBinary, J2STemplate,
	 J2SDeclClass, J2SClass, J2SClassElement, 
	 J2SDollar, J2STilde,
	 TsInterface, TsInterfaceProperty, TsInterfacePropertyName,
	 TsType, TsTypeArray, TsTypeFunction, TsTypeBinary }
         from "./ast.mjs";
export {j2sParser, j2sTagtoexpr}
const j2sParser = ((inputPort, conf, plugins) => { let tildeLevel = configGet(conf, {"tilde-level": 0});let lang = configGet(conf, {"language": "hopscript"});let debugFunction = (configGet(conf, {"debug": 0}) >= 2);let currentMode = 'normal';let sourceMap = false;let funSrc = configGet(conf, {"fun-src": true});let interfaces = null;let types = null;let typescript = (lang === "typescript") || (configGet(conf, 'typescript'));let esModule = false;let withTilde = ((proc) => { tildeLevel = (tildeLevel + 1);{ let res = proc(); tildeLevel = (tildeLevel - 1);return res; } }
);let withDollar = ((proc) => { tildeLevel = (tildeLevel - 1);{ let res = proc(); tildeLevel = (tildeLevel + 1);return res; } }
);let currentLoc = (() => { return makeLoc(inputPortName(inputPort), inputPortPosition(inputPort)); }
);let newDeclThis = ((loc) => { return new J2SDecl({'loc': loc,'id': 'this','_scmid': 'this','binder': 'let-opt'}); }
);let exports = null;let parseEofError = ((token) => { return parseTokenError("Unexpected end of file", ((queueEmptyp(_openTokens_)) ? (token) : (queuePeek(_openTokens_)))); }
);let parseTokenError = ((msg, token) => { { const mc1004 = tokenLoc(token); if (mc1004 instanceof Location) { const fname = mc1004.filename, loc = mc1004.offset;; throw new $ioParseError({'proc': "hopc ("+lang+")",'msg': msg,'obj': tokenValue(token),'fname': fname,'location': loc}); } else throw new $ioParseError({'proc': "hopc ("+lang+")",'msg': msg,'obj': tokenValue(token)}); } }
);let parseTokenWarning = ((msg, token) => { return withHandler(((e) => { if ((biglooWarning() > 0)) { exceptionNotify(e);display("ignoring...\n", currentErrorPort()); }
return new J2SNop({'loc': tokenLoc(token)}); }
), parseTokenError(msg, token)); }
);let parseError = ((msg, obj) => { if (tokenp(obj)) return parseTokenError(msg, obj); else { let fname = inputPortName(inputPort), loc = inputPortPosition(inputPort); throw new $ioParseError({'proc': "hopscript",'msg': msg,'obj': readLine(inputPort),'fname': fname,'location': loc}); } }
);let parseNodeError = ((msg, node) => { { let obj1005 = node; { const mc1006 = obj1005.loc; if (mc1006 instanceof Location) { const fname = mc1006.filename, loc = mc1006.offset;; throw new $ioParseError({'proc': "hopscript",'msg': msg,'obj': typeof(node),'fname': fname,'location': obj1005.loc}); } else throw new $ioParseError({'proc': "hopscript",'msg': msg,'obj': typeof(node)}); } } }
);let _peekedTokens_ = queueInit();let _previousTokenType_ = undefined;let _openTokens_ = queueInit();let peekToken = (() => { if (queueEmptyp(_peekedTokens_)) { let tok = read_rp(j2sLexer(), inputPort, lang, conf); _peekedTokens_ = queueInit(tok);if (tokenType(queuePeek(_peekedTokens_)) === 'NEWLINE') { _previousTokenType_ = 'NEWLINE';_peekedTokens_ = queuePop(_peekedTokens_);return peekToken(); }
 else return queuePeek(_peekedTokens_); } else return queuePeek(_peekedTokens_); }
);let tokenPushBack$ = ((token) => { if (atNewLineTokenp()) return _peekedTokens_ = queuePush(token, queuePush(makeToken('NEWLINE', "\n", tokenLoc(token)), _peekedTokens_)); else return _peekedTokens_ = queuePush(token, _peekedTokens_); }
);let peekTokenType = (() => { return tokenType(peekToken()); }
);let peekTokenValue = (() => { return tokenValue(peekToken()); }
);let atNewLineTokenp = (() => { return _previousTokenType_ === 'NEWLINE'; }
);let pushOpenToken = ((token) => { _openTokens_ = queuePush(token, _openTokens_);return token; }
);let popOpenToken = ((token) => { if (queueEmptyp(_openTokens_)) error("js2scheme", "Cannot pop token \""+tokenValue(token)+"\".", tokenLoc(token)); else _openTokens_ = queuePop(_openTokens_);return token; }
);let consumeToken$ = ((type) => { let token = consumeAny$(); if (tokenType(token) === type) return token; else return parseTokenError("expecting \""+type+"\" got \""+tokenType(token)+"\".", token); });let consume$ = ((type) => { return tokenValue(consumeToken$(type)); }
);let consumeOf$ = ((types) => { { let token = consumeAny$(), typ = tokenType(token); if (types?.includes(typ)) return token; else return parseTokenError("expecting one of \""+types+", )\"", token); } }
);let consume2$ = ((type1, type2) => { { let token = consumeAny$(), typ = tokenType(token); if ((typ === type1) || (typ === type2)) return token; else return parseTokenError("expecting \""+type1+"\" or \""+type2+"\", got \""+tokenType(token)+"\"", token); } }
);let consumeAny$ = (() => { let res = peekToken(); _previousTokenType_ = tokenType(res);_peekedTokens_ = queuePop(_peekedTokens_);return res; });let consumeStatementSemicolon$ = ((where, loc) => { if (peekTokenType() === 'SEMICOLON') return consumeAny$(); else if (peekTokenType() === 'NEWLINE') return consumeAny$(); else if ((peekTokenType() === 'RBRACE') || (atNewLineTokenp()) || (peekTokenType() === 'EOF')) return peekToken(); else return parseTokenError("a [@"+where+"]: \";\", or newline expected", peekToken()); }
);let peekTokenIdp = ((val) => { if (peekTokenType() === 'ID') return peekTokenValue() === val; else return peekTokenType() === val; }
);let eofp = (() => { return peekTokenType() === 'EOF'; }
);let parserController = false;let readRegexp = ((introToken) => { if (introToken === '/=') unreadChar$('=', inputPort);{ let token = read_rp(j2sRegexLexer(), inputPort); switch (tokenType(token)) { case 'EOF': return parseTokenError("Unfinished regular expression literal", token); break; case 'ERROR': return parseError("Bad regular-expression literal", token); break; default: return token; } } }
);let sourceElementMode$ = ((node) => { let mode = ((configGet(conf, {"parser": false}) === 'eval-strict') ? ('strict') : (javascriptMode(node))); if (mode) if (currentMode !== 'hopscript') { if (mode === 'hopscript') conf = configAdd(conf, {"type-annotations": true});return currentMode = mode; }
 });let sourceElements = (() => { const loop$ = ((function loop(revSes, first) { if (eofp()) if (nullp(revSes)) return new J2SBlock({'loc': makeLoc(inputPortName(inputPort), 0),'endloc': makeLoc(inputPortName(inputPort), 0),'nodes': null}); else { let lastnode = car(revSes), nodes = reverse$(revSes); { let obj1007 = car(nodes); { let obj1008 = lastnode; return new J2SBlock({'loc': obj1007.loc,'endloc': obj1008.loc,'nodes': nodes}); } } } else { let tok = peekToken(), el = sourceElement(); if (el === 'source-map') return loop(revSes, false); else if (first) { sourceElementMode$(el);return loop(cons(el, revSes), (el instanceof J2SString) || ((el instanceof J2SStmtExpr) && (((obj1009 => { return obj1009.expr instanceof J2SString; })(el))))); }
 else return loop(cons(el, revSes), false); } })(null, true)); return loop$; });let sourceId = (() => { let token = peekToken(); { let p = (plugins) && (assq(tokenValue(token), plugins)); if (p) return cdr(p)(consumeAny$(), true, conf, parserController); else if (tokenValue(token) === 'async') { let token = consumeAny$(), next = peekTokenType(); if (next === 'function') return asyncDeclaration(token); else if (next === '=>') return asyncDeclaration(token); else { tokenPushBack$(token);return statement(); }
 } else if (tokenValue(token) === 'sealed') { let token = consumeAny$(), next = peekTokenType(); if (next === 'class') return recordDeclaration(); else { tokenPushBack$(token);return statement(); }
 } else if (tokenValue(token) === 'service') return serviceDeclaration(); else if ((tokenValue(token) === 'generic') && (currentMode === 'hopscript')) return genericDeclaration(); else if ((tokenValue(token) === 'method') && (currentMode === 'hopscript')) return methodDeclaration(); else return statement(); } });let sourceElement = (() => { switch (peekTokenType()) { case 'function': return functionDeclaration(); break; case 'ID': return sourceId(); break; case 'class': return classDeclaration(); break; case 'record': return recordDeclaration(); break; case 'RESERVED': switch (peekTokenValue()) { case 'import': return $$import(consumeAny$()); break; case 'export': return $$export(consumeAny$()); break; default: return statement(); } break; case 'type': if (typescript) return typeDeclList(); else return statement(); break; case 'interface': if (typescript) return $$interface(); else return statement(); break; case 'EOF': return parseEofError(peekToken()); break; case 'ERROR': return parseTokenError("Error", consumeAny$()); break; case 'SOURCEMAP': { const loop$ = ((function loop(tok) { if (eofp()) { if (configGet(conf, {"source-map": true})) sourceMap = makeFileName(dirname(inputPortName(inputPort)), tokenValue(tok));return 'source-map'; }
 else if (peekTokenType() === 'SOURCEMAP') return loop(consumeAny$()); else return parseTokenWarning("Unexpected source-map", tok); })(consumeAny$())); return loop$; } break; case 'SOURCEELEMENT': return tokenValue(consumeAny$()); break; default: return statement(); } }
);let absoluteFileNamep = ((path) => { return ((path.length > 0)) && (path[0] === fileSeparator()); }
);let replElement = (() => { switch (peekTokenType()) { case 'function': return functionDeclaration(); break; case 'ID': return sourceId(); break; case 'class': return classDeclaration(); break; case 'record': return recordDeclaration(); break; case 'EOF': return tokenValue(consumeAny$()); break; case 'ERROR': return parseTokenError("Error", consumeAny$()); break; default: return statement(); } }
);let statement = (() => { switch (peekTokenType()) { case 'LBRACE': return block(); break; case 'var': return varDeclList(false); break; case 'let': return letDeclList(false); break; case 'const': return constDeclList(false); break; case 'SEMICOLON': return emptyStatement(); break; case 'if': return iff(); break; case 'for':case 'while':case 'do':return iteration();break; case 'continue': return $$continue(); break; case 'break': return $$break(); break; case 'return': return $$return(); break; case 'with': return $$with(); break; case 'switch': return $$switch(); break; case 'throw': return $$throw(); break; case 'try': return trie(); break; case 'ID': return labeledOrExpr(); break; case 'function': return functionDeclaration(); break; case 'class': return classDeclaration(); break; case 'record': return recordDeclaration(); break; case 'debugger': return debuggerStatement(); break; default: return expressionStatement(); } }
);let block = (() => { let token = pushOpenToken(consumeToken$('LBRACE')); { const loop$ = ((function loop(revStats) { switch (peekTokenType()) { case 'RBRACE': { let etoken = consumeAny$(); popOpenToken(etoken);return new J2SBlock({'loc': tokenLoc(token),'endloc': tokenLoc(etoken),'nodes': reverse$(revStats)}); } break; default: return loop(cons(statement(), revStats)); } })(null)); return loop$; } });let declList = ((token, inForInitp, constrinit, constr) => { const loop$ = ((function loop(vars) { switch (peekTokenType()) { case 'SEMICOLON': if (!inForInitp) consumeAny$();return new J2SVarDecls({'loc': tokenLoc(token),'decls': vars}); break; case 'COMMA': consumeAny$();return loop(append(vars, $$var(inForInitp, constrinit, constr))); break; case 'in': if (!inForInitp) return parseTokenError("Illegal \"in\" variable declaration", peekToken()); else return new J2SVarDecls({'loc': tokenLoc(token),'decls': vars}); break; default: if ((peekTokenType() === 'ID') && (tokenValue(peekToken()) === 'of') && (inForInitp)) return new J2SVarDecls({'loc': tokenLoc(token),'decls': vars}); else if ((!inForInitp) && ((atNewLineTokenp()) || (peekTokenType() === 'RBRACE') || (peekTokenType() === 'EOF'))) return new J2SVarDecls({'loc': tokenLoc(token),'decls': vars}); else return parseTokenError("Illegal variable declaration list", consumeAny$()); } })($$var(inForInitp, constrinit, constr))); return loop$; });let varDeclList = ((inForInitp) => { return declList(consumeToken$('var'), inForInitp, ((loc, id, val, ty, opt) => { return new J2SDeclInit({'loc': loc,'id': id,'val': val,'utype': ty,'optional': opt}); }
), ((loc, id, ty, opt) => { return new J2SDecl({'loc': loc,'id': id,'utype': ty,'optional': opt}); }
)); }
);let letDeclList = ((inForInitp) => { return declList(consumeToken$('let'), inForInitp, ((loc, id, val, ty, opt) => { return new J2SDeclInit({'loc': loc,'id': id,'binder': 'let','val': val,'utype': ty,'optional': opt}); }
), ((typescript) ? (((loc, id, ty, opt) => { return new J2SDecl({'loc': loc,'id': id,'binder': 'let','utype': ty,'optional': opt}); }
)) : (((loc, id, ty, opt) => { return new J2SDeclInit({'loc': loc,'id': id,'binder': 'let','val': new J2SUndefined({'type': 'undefined','loc': loc}),'utype': ty,'optional': opt}); }
)))); }
);let constDeclList = ((inForInitp) => { return declList(consumeToken$('const'), inForInitp, ((loc, id, val, ty, opt) => { return new J2SDeclInit({'loc': loc,'id': id,'writable': false,'binder': 'let','val': val,'utype': ty,'optional': opt}); }
), ((loc, id, ty, opt) => { return new J2SDeclInit({'loc': loc,'id': id,'writable': false,'binder': 'let','val': new J2SUndefined({'type': 'undefined','loc': loc}),'utype': ty,'optional': opt}); }
)); }
);let typeDeclList = (() => { consumeToken$('type');{ const loop$ = ((function loop() { types = cons(tokenValue(consumeToken$('ID')), types);consumeToken$('=');typescriptType();if (peekTokenType() === 'COMMA') { consumeAny$();return loop(); }
 else return emptyStatement(); })()); return loop$; } }
);let $$interface = (() => { let tok = consumeToken$('interface'); { let id = consumeToken$('ID'); interfaces = cons(tokenValue(id), interfaces);return new TsInterface({'loc': tokenLoc(tok),'id': tokenValue(id),'decl': "interface",'properties': interfaceProperties()}); } });let interfaceProperties = (() => { consumeToken$('LBRACE');{ const loop$ = ((function loop() { if (peekTokenType() === 'RBRACE') { consumeAny$();return null; }
 else { let prop = interfaceProperty(); switch (peekTokenType()) { case 'SEMICOLON': consumeAny$();return cons(prop, loop()); break; case 'RBRACE': consumeAny$();return list(prop); break; default: return parseTokenError("Illegal type expression", consumeAny$()); } } })()); return loop$; } }
);let interfaceProperty = (() => { { let tok = consumeAny$(), name = (() => { switch (tokenType(tok)) { case 'ID':case 'class':case 'in':return new J2SString({'loc': tokenLoc(tok),'val': symboltostring(tokenValue(tok))});break; case 'LBRACKET': { let name = consumeOf$(['ID', 'class', 'in']); consumeToken$(':');{ let fakename = new J2SString({'loc': tokenLoc(tok),'val': symboltostring(tokenValue(name))}), ty = typescriptType(); consumeToken$('RBRACKET');return new TsInterfacePropertyName({'loc': tokenLoc(tok),'fakename': fakename,'type': ty}); } } break; default: return parseTokenError("expecting \"ident\", got \""+tokenType(tok)+"\"", tok); } })(); { let opt = ((peekTokenType() === '?') ? ((consumeAny$(), true)) : undefined); consumeToken$(':');{ let ty = typescriptType(); return new TsInterfaceProperty({'loc': tokenLoc(tok),'name': name,'optional': opt,'type': ty}); } } } }
);let typeName = ((ty) => { if (ty === 'vector') return 'jsvector'; else return ty; }
);let typescriptTypeList = (() => { let t = typescriptType(); if (peekTokenType() === 'COMMA') { consumeAny$();return typescriptTypeList(); }
 else return t; });let typescriptArgsList = (() => { consumeToken$('ID');if (peekTokenType() === '?') consumeAny$();consumeToken$(':');{ let t = typescriptType(); if (peekTokenType() === 'COMMA') { consumeAny$();return cons(t, typescriptArgsList()); }
 else return list(t); } }
);let typescriptSimpleType = (() => { switch (peekTokenType()) { case 'ID': { const loop$ = ((function loop(ty) { if (peekTokenType() === 'DOT') { consumeAny$();return loop(symbolAppend(ty, '.', typeName(tokenValue(consumeToken$('ID'))))); }
 else return ty; })(typeName(tokenValue(consumeToken$('ID'))))); return loop$; } break; case 'null': consumeAny$();return 'null'; break; case 'LPAREN': { let tok = consumeAny$(); if (peekTokenType() === 'ID') { let id = consumeAny$(); if (peekTokenType() === ':') { consumeAny$();{ let domain = list(typescriptType()); if (peekTokenType() !== 'RPAREN') { consumeToken$('COMMA');domain = append(domain, typescriptArgsList()); }
consumeToken$('RPAREN');consumeToken$('=>');{ let range = typescriptType(); return new TsTypeFunction({'loc': tokenLoc(tok),'domain': domain,'range': range}); } } }
 else { tokenPushBack$(id);{ let t = typescriptType(); consumeToken$('RPAREN');return t; } }
 } else { let t = typescriptType(); consumeToken$('RPAREN');return t; } } break; case 'LBRACE': return new TsInterface({'loc': tokenLoc(peekToken()),'properties': interfaceProperties()}); break; case 'void': consumeAny$();return 'void'; break; case 'STRING': consumeAny$();return 'string'; break; case 'NUMBER': consumeAny$();return 'number'; break; case 'true':case 'false':consumeAny$();return peekTokenType();break; default: return parseTokenError("Illegal type expression", consumeAny$()); } }
);let typescriptType = (() => { { let loc = currentLoc(), ty = typescriptSimpleType(); switch (peekTokenType()) { case 'LBRACKET': consumeAny$();consumeToken$('RBRACKET');return new TsTypeArray({'loc': loc,'of': ty}); break; case 'BIT_OR': consumeAny$();{ let tz = typescriptType(); return new TsTypeBinary({'loc': loc,'op': 'BIT_OR','lhs': ty,'rhs': tz}); } break; case '&': consumeAny$();{ let tz = typescriptType(); return new TsTypeBinary({'loc': loc,'op': '&','lhs': ty,'rhs': tz}); } break; case 'OTAG': consumeAny$();return 'any'; break; case '<': { let tok = consumeAny$(), ty = typescriptType(); consumeToken$('>');return 'any'; } break; default: return ty; } } }
);let optType = (() => { if ((peekTokenType() === ':') && (typescript)) { consumeAny$();return typescriptType(); }
 else if (peekTokenType() === 'type') return typeName(tokenValue(consumeAny$())); else return 'unknown'; }
);let $$var = ((inForInitp, constrinit, constr) => { let id = peekToken(); switch (tokenType(id)) { case 'ID': { let tid = consumeAny$(); { const loop$ = ((function loop(ty) { if ((tokenType(id) === 'ID') || (currentMode === 'normal')) switch (peekTokenType()) { case ':': if ((typescript) && (!ty)) { let tok = consumeAny$(); return loop(typescriptType()); } else return parseTokenError("unexpected token", peekToken()); break; case '=': { let token = consumeAny$(), expr = assigExpr(inForInitp, false, false); return list(constrinit(tokenLoc(tid), tokenValue(id), expr, (ty) || (optType()), false)); } break; default: return list(constr(tokenLoc(tid), tokenValue(id), (ty) || (optType()), false)); } else return parseTokenError("Illegal lhs", id); })(false)); return loop$; } } break; case 'undefined':case 'NaN':case 'Infinity':consumeAny$();switch (peekTokenType()) { case '=': consumeAny$();return list(assigExpr(inForInitp, false, false)); break; default: return parseTokenError("Illegal variable declaration", id); }break; case 'LBRACE':case 'LBRACKET':{ let objectp = peekTokenType() === 'LBRACE', loc = tokenLoc(id), lhs = ((objectp) ? (objectLiteral(true)) : (arrayLiteral(true, false, 'array'))), decl = constrinit(loc, gensym('%obj'), new J2SUndefined({'type': 'undefined','loc': loc}), 'unknown', false), bindings = j2sDestructure(lhs, decl, true); if (inForInitp) { let tmp = new J2SDecl({'loc': loc,'id': gensym('%i')}), rhs = new J2SRef({'loc': loc,'type': 'unknown','decl': tmp}); { let obj1010 = decl; obj1010.binder = 'let';obj1010.val = new J2SDProducer({'loc': loc,'size': ((objectp) ? (-1) : (length(bindings))),'decl': decl,'type': ((objectp) ? ('object') : ('array')),'expr': rhs}); }return cons_(tmp, decl, bindings); } else { let assig = consumeToken$('='), rhs = assigExpr(inForInitp, false, false); { let obj1011 = decl; obj1011.binder = 'let';obj1011.val = new J2SDProducer({'loc': loc,'size': ((objectp) ? (-1) : (length(bindings))),'type': ((objectp) ? ('object') : ('array')),'decl': decl,'expr': rhs}); }return cons(decl, bindings); } }break; default: return parseTokenError("Illegal lhs", id); } });let emptyStatement = (() => { return new J2SNop({'loc': tokenLoc(consumeToken$('SEMICOLON'))}); }
);let iff = (() => { let tif = consumeAny$(); pushOpenToken(consumeToken$('LPAREN'));{ let test = expression(false, false); popOpenToken(consumeToken$('RPAREN'));{ let then = statement(); switch (peekTokenType()) { case 'else': { let tok = consumeAny$(), otherwise = statement(); return new J2SIf({'loc': tokenLoc(tif),'test': test,'then': then,'else': otherwise}); } break; default: return new J2SIf({'loc': tokenLoc(tif),'test': test,'then': then,'else': new J2SNop({'loc': tokenLoc(tif)})}); } } } });let iteration = (() => { switch (peekTokenType()) { case 'for': return $$for(); break; case 'while': return $$while(); break; case 'do': return doWhile(); break; } }
);let $$for = (() => { let initFirstPart = ((tok0) => { switch (tok0) { case 'var': return varDeclList(true); break; case 'let': return letDeclList(true); break; case 'const': return constDeclList(true); break; case 'SEMICOLON': return false; break; default: return expression(true, false); } }
);{ let loc = tokenLoc(consumeToken$('for')); pushOpenToken(consumeToken$('LPAREN'));{ let tok0 = peekTokenType(), firstPart = initFirstPart(tok0); switch (peekTokenType()) { case 'SEMICOLON': return forInit_Test_Incr(loc, (firstPart) || (new J2SNop({'loc': loc}))); break; case 'in': return forIn(loc, firstPart); break; case 'ID': if (tokenValue(peekToken()) === 'of') return forIn(loc, firstPart); break; } } } }
);let forInit_Test_Incr = ((loc, init) => { consume$('SEMICOLON');{ let test = (() => { switch (peekTokenType()) { case 'SEMICOLON': return false; break; default: return expression(false, false); } })(); consume$('SEMICOLON');{ let incr = (() => { switch (peekTokenType()) { case 'RPAREN': return false; break; default: return expression(false, false); } })(); popOpenToken(consumeToken$('RPAREN'));{ let body = statement(); return new J2SFor({'loc': loc,'init': (init) || (new J2SNop({'loc': loc})),'test': (test) || (new J2SBool({'val': true,'loc': loc})),'incr': (incr) || (new J2SUndefined({'type': 'undefined','loc': loc})),'body': body}); } } } }
);let forIn = ((loc, lhs) => { { let tok = consumeAny$(), op = ((tokenType(tok) === 'in') ? ('in') : ((((tokenType(tok) === 'ID') && (tokenValue(tok) === 'of')) ? ('of') : (parseError("Token 'in' or 'of' expectede", tok))))), errorToken = peekToken(), obj = expression(false, false), ignoreRparen = consume$('RPAREN'), body = statement(); if (lhs instanceof J2SVarDecls) { let obj1012 = lhs; if (nullp(lhs)) return parseError("Illegal empty declaration", errorToken); else if (nullp(cdr(obj1012.decls))) return new J2SForIn({'loc': loc,'op': op,'lhs': lhs,'obj': obj,'body': body}); else if ((cadr(obj1012.decls) instanceof J2SDeclInit) && (((obj1013 => { return obj1013.val instanceof J2SDProducer; })(cadr(obj1012.decls))))) { let tmps = cdr(obj1012.decls); obj1012.decls = list(car(obj1012.decls));{ let body = new J2SBlock({'loc': loc,'endloc': loc,'nodes': list(new J2SVarDecls({'loc': loc,'decls': tmps}), body)}); return new J2SForIn({'loc': loc,'op': op,'lhs': lhs,'obj': obj,'body': body}); } } else return parseError("Only one declaration allowed", errorToken); } else if (!(lhs instanceof J2SUnresolvedRef)) return parseError("Variable reference or declaration required", errorToken); else return new J2SForIn({'loc': loc,'op': op,'lhs': lhs,'obj': obj,'body': body}); } }
);let $$while = (() => { let token = consumeToken$('while'); pushOpenToken(consumeToken$('LPAREN'));{ let test = expression(false, false); popOpenToken(consumeToken$('RPAREN'));{ let body = statement(); return new J2SWhile({'loc': tokenLoc(token),'test': test,'body': body}); } } });let doWhile = (() => { { let loc = tokenLoc(consumeToken$('do')), body = statement(); consume$('while');pushOpenToken(consumeToken$('LPAREN'));{ let test = expression(false, false); popOpenToken(consumeToken$('RPAREN'));return new J2SDo({'loc': loc,'test': test,'body': body}); } } }
);let $$continue = (() => { let loc = tokenLoc(consumeToken$('continue')); if ((peekTokenType() === 'ID') && (!(atNewLineTokenp()))) { let id = consume$('ID'); consumeStatementSemicolon$("continue", loc);return new J2SContinue({'loc': loc,'id': id}); } else { consumeStatementSemicolon$("continue", loc);return new J2SContinue({'loc': loc,'id': false}); }
 });let $$break = (() => { let loc = tokenLoc(consumeToken$('break')); if ((peekTokenType() === 'ID') && (!(atNewLineTokenp()))) { let id = consume$('ID'); consumeStatementSemicolon$("break", loc);return new J2SBreak({'loc': loc,'id': id}); } else { consumeStatementSemicolon$("break", loc);return new J2SBreak({'loc': loc}); }
 });let $$return = (() => { let loc = tokenLoc(consumeToken$('return')); if (((() => { switch (peekTokenType()) { case 'EOF':case 'ERROR':case 'SEMICOLON':return true;break; default: return false; } })()) || (atNewLineTokenp())) { consumeStatementSemicolon$("return", loc);return new J2SReturn({'loc': loc,'expr': new J2SUndefined({'loc': loc})}); }
 else if (peekTokenType() === 'RBRACE') return new J2SReturn({'loc': loc,'expr': new J2SUndefined({'loc': loc})}); else { let expr = expression(false, false); consumeStatementSemicolon$("return", loc);return new J2SReturn({'loc': loc,'expr': expr}); } });let $$with = (() => { let token = consumeToken$('with'); pushOpenToken(consumeToken$('LPAREN'));{ let expr = expression(false, false); popOpenToken(consumeToken$('RPAREN'));{ let body = statement(); return new J2SWith({'loc': tokenLoc(token),'obj': expr,'block': body}); } } });let $$switch = (() => { let token = consumeToken$('switch'); pushOpenToken(consumeToken$('LPAREN'));{ let key = expression(false, false); popOpenToken(consumeToken$('RPAREN'));{ let cases = caseBlock(); return new J2SSwitch({'loc': tokenLoc(token),'key': key,'cases': cases}); } } });let caseBlock = (() => { pushOpenToken(consumeToken$('LBRACE'));{ const loop$ = ((function loop(revCases, defaultCaseDonep) { switch (peekTokenType()) { case 'RBRACE': popOpenToken(consumeAny$());return reverse$(revCases); break; case 'case': return loop(cons(caseClause(), revCases), defaultCaseDonep); break; case 'default': if (defaultCaseDonep) return error("Only one default-clause allowed", peekToken(), peekToken()); else return loop(cons(defaultClause(), revCases), true); break; } })(null, false)); return loop$; } }
);let caseClause = (() => { let token = consumeToken$('case'); { let expr = expression(false, false); consume$(':');{ let body = switchClauseStatements(tokenLoc(token)); return new J2SCase({'loc': tokenLoc(token),'expr': expr,'body': body}); } } });let defaultClause = (() => { { let token = consumeToken$('default'), loc = tokenLoc(token); consume$(':');return new J2SDefault({'loc': loc,'expr': new J2SUndefined({'type': 'undefined','loc': loc}),'body': switchClauseStatements(tokenLoc(token))}); } }
);let switchClauseStatements = ((loc) => { const loop$ = ((function loop(revStats) { switch (peekTokenType()) { case 'RBRACE':case 'EOF':case 'ERROR':case 'default':case 'case':return new J2SBlock({'loc': loc,'endloc': tokenLoc(peekToken()),'nodes': reverse$(revStats)});break; default: return loop(cons(statement(), revStats)); } })(null)); return loop$; });let $$throw = (() => { let token = consumeToken$('throw'); if ((atNewLineTokenp()) || (peekTokenType() === 'NEWLINE')) parseTokenError("Throw must have a value", peekToken());peekToken();if ((atNewLineTokenp()) || (peekTokenType() === 'NEWLINE')) parseTokenError("Throw must have a value", peekToken());{ let expr = expression(false, false), loc = tokenLoc(token); consumeStatementSemicolon$("throw", loc);return new J2SThrow({'loc': loc,'expr': expr}); } });let trie = (() => { let loc = tokenLoc(consumeToken$('try')); { let body = block(); { let catchPart = false, finallyPart = false; if (peekTokenType() === 'catch') catchPart = $$catch();if (peekTokenType() === 'finally') finallyPart = $$finally();return new J2STry({'loc': loc,'body': body,'catch': (catchPart) || (new J2SNop({'loc': loc})),'finally': (finallyPart) || (new J2SNop({'loc': loc}))}); } } });let $$catch = (() => { let loc = tokenLoc(consumeToken$('catch')); switch (peekTokenType()) { case 'LPAREN': pushOpenToken(consumeToken$('LPAREN'));switch (peekTokenType()) { case 'ID': { let id = consume$('ID'); popOpenToken(consumeToken$('RPAREN'));{ let body = block(); return new J2SCatch({'loc': loc,'param': new J2SDecl({'loc': loc,'id': id,'binder': 'param'}),'body': body}); } } break; case 'LBRACE':case 'LBRACKET':{ let vars = $$var(true, ((loc, id, val, ty, opt) => { return new J2SDeclInit({'loc': loc,'id': id,'val': val,'utype': ty,'optional': opt}); }
), ((loc, id, ty, opt) => { return new J2SDecl({'loc': loc,'id': id,'utype': ty,'optional': opt}); }
)); popOpenToken(consumeToken$('RPAREN'));{ let obj1014 = car(vars); obj1014.binder = 'param'; }return new J2SCatch({'loc': loc,'param': car(vars),'body': new J2SBlock({'loc': loc,'endloc': loc,'nodes': list(new J2SVarDecls({'loc': loc,'decls': cdr(vars)}), block())})}); }break; default: return parseTokenError("Unexpected token", consumeAny$()); } break; case 'LBRACE': { let body = block(); return new J2SCatch({'loc': loc,'param': new J2SDecl({'loc': loc,'id': '%nil','binder': 'param'}),'body': body}); } break; } });let $$finally = (() => { consume$('finally');return block(); }
);let labeledOrExpr = (() => { { let idToken = consumeToken$('ID'), nextTokenType = peekTokenType(); if (nextTokenType === ':') { consumeAny$();return new J2SLabel({'loc': tokenLoc(idToken),'id': tokenValue(idToken),'body': statement()}); }
 else if (tokenValue(idToken) === 'async') if (nextTokenType === 'function') return asyncDeclaration(idToken); else if (nextTokenType === '=>') return asyncDeclaration(idToken); else { tokenPushBack$(idToken);return expressionStatement(); }
 else if (tokenValue(idToken) === 'sealed') if (nextTokenType === 'class') return recordDeclaration(); else { tokenPushBack$(idToken);return expressionStatement(); }
 else { tokenPushBack$(idToken);return expressionStatement(); }
 } }
);let debuggerStatement = (() => { let token = consumeToken$('debugger'); return new J2SNop({'loc': tokenLoc(token)}); });let expressionStatement = (() => { let tok = peekToken(), expr = expression(false, false); consumeStatementSemicolon$("expression \""+tokenValue(tok)+"\"", tokenLoc(tok));{ let obj1015 = expr; return new J2SStmtExpr({'loc': obj1015.loc,'expr': expr}); } });let functionDeclaration = (() => { return $$function(true, consumeAny$(), false); }
);let genericDeclaration = (() => { let f = functionDeclaration(); { let obj1016 = f; { let obj1017 = obj1016.val; if (nullp(obj1017.params)) throw new $ioParseError({'proc': "hopc",'msg': "generic functions require at least one argument",'obj': obj1016.id,'fname': locFilename(obj1017.loc),'location': locOffset(obj1017.loc)}); else { let endloc = nodeEndloc(obj1017.body), nparams = map(((p) => { return p.duplicate({'key': astDeclKey()}); }
), obj1017.params), nbody = new J2SBlock({'loc': obj1017.loc,'endloc': endloc,'nodes': list(new J2SReturn({'loc': obj1017.loc,'tail': true,'expr': new J2SCall({'loc': obj1017.loc,'fun': new J2SCall({'loc': obj1017.loc,'fun': new J2SAccess({'loc': obj1017.loc,'obj': new J2SRef({'loc': obj1017.loc,'type': 'unknown','decl': f}),'field': new J2SString({'loc': obj1017.loc,'val': "dispatchValue"})}),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': obj1017.loc})),'args': list(new J2SRef({'loc': obj1017.loc,'type': 'unknown','decl': car(nparams)}))}),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': obj1017.loc})),'args': map(((p) => { return new J2SRef({'loc': obj1017.loc,'type': 'unknown','decl': p}); }
), nparams)}),'from': false}))}), nval = new J2SFun({'name': obj1017.name,'params': nparams,'body': nbody,'loc': obj1017.loc}), gen = new J2SStmtExpr({'loc': obj1017.loc,'expr': new J2SAssig({'loc': obj1017.loc,'lhs': new J2SAccess({'loc': obj1017.loc,'obj': new J2SRef({'loc': obj1017.loc,'type': 'unknown','decl': f}),'field': new J2SString({'loc': obj1017.loc,'val': "__proto__"})}),'rhs': new J2SNew({'loc': obj1017.loc,'clazz': new J2SAccess({'loc': obj1017.loc,'obj': new J2SUnresolvedRef({'loc': obj1017.loc,'id': 'hop'}),'field': new J2SString({'loc': obj1017.loc,'val': "Generic"})}),'args': list(((obj1018 => { if (obj1018.utype === 'unknown') new J2SUndefined({'type': 'undefined','loc': obj1017.loc});return new J2SUnresolvedRef({'loc': obj1017.loc,'id': obj1018.utype}); })(car(obj1017.params))), obj1016.val)})})}); obj1016.val = nval;tokenPushBack$(makeToken('SOURCEELEMENT', gen, obj1017.loc));return f; } } } });let methodDeclaration = (() => { let f = functionDeclaration(); { let obj1019 = f; { let obj1020 = obj1019.val; if (nullp(obj1020.params)) throw new $ioParseError({'proc': "hopc",'msg': "methods require at least one argument",'obj': obj1019.id,'fname': locFilename(obj1020.loc),'location': locOffset(obj1020.loc)}); else if (((obj1021 => { return obj1021.utype === 'unknown'; })(car(obj1020.params)))) throw new $ioParseError({'proc': "hopc",'msg': "methods require a typed first argument",'obj': obj1019.id,'fname': locFilename(obj1020.loc),'location': locOffset(obj1020.loc)}); else { let obj1022 = car(obj1020.params); { let gen = new J2SUnresolvedRef({'loc': obj1020.loc,'id': obj1019.id}), rec = new J2SUnresolvedRef({'loc': obj1020.loc,'id': obj1022.utype}); obj1020.ismethodof = list('method', obj1019.id, obj1022.utype);return new J2SCall({'loc': obj1020.loc,'fun': new J2SAccess({'loc': obj1020.loc,'obj': gen,'field': new J2SString({'loc': obj1020.loc,'val': "addMethod"})}),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': obj1020.loc})),'args': list(rec, obj1019.val)}); } } } } });let asyncDeclaration = ((tok) => { let fun = functionDeclaration(); if (fun instanceof J2SDeclFun) { let obj1023 = fun; obj1023.val = asynctogenerator(obj1023.val);return fun; } else return parseTokenError("Illegal async function declaration", tok); });let classDeclaration = (() => { return clazz(true); }
);let recordDeclaration = (() => { return record(); }
);let functionExpression = (() => { return $$function(false, consumeToken$('function')); }
);let serviceDeclaration = (() => { let token = consumeAny$(), ntype = peekTokenType(); tokenPushBack$(token);if (ntype === 'ID') return $service(true); else return statement(); });let serviceExpression = (() => { return $service(false); }
);let classExpression = (() => { return clazz(false); }
);let asynctogenerator = ((fun) => { { let obj1024 = fun; if ((!(configGet(conf, 'es2017-async'))) && (!(lang === "hopscript")) && (!typescript) && (!(['hopscript', 'strict']?.includes(currentMode)))) return parseNodeError("async function requires hopscript or ecmascript2017 mode", fun); else if (obj1024.generator) return parseNodeError("wrong async function declaration", fun); else { let obj1025 = obj1024.body; { let gen = new J2SFun({'thisp': obj1024.thisp,'loc': obj1025.loc,'src': funSrc,'generator': true,'name': symbolAppend(obj1024.name, '*'),'mode': 'strict','body': obj1024.body}); obj1024.body = new J2SBlock({'loc': obj1025.loc,'endloc': obj1025.endloc,'nodes': list(new J2SReturn({'loc': obj1025.loc,'tail': true,'expr': new J2SCall({'loc': obj1025.loc,'fun': new J2SHopRef({'loc': obj1025.loc,'id': 'js-spawn','type': 'any','module': false}),'thisargs': null,'args': list(gen, new J2SUnresolvedRef({'loc': obj1025.loc,'id': 'this'}), new J2SHopRef({'loc': obj1025.loc,'id': '%this','type': 'any','module': false}))}),'from': false}))});return fun; } } } }
);let asyncExpression = ((tok) => { let fun = primary(false, false); if (fun instanceof J2SFun) return asynctogenerator(fun); else return parseTokenError("Illegal async function expression", tok); });let arrowParamBindExitDesctructurep = ((p) => { if (p instanceof J2SBindExit) { let obj1026 = p; { let obj1027 = obj1026.stmt; if (car(obj1027.nodes) instanceof J2SVarDecls) { let obj1028 = car(obj1027.nodes); if ((pairp(obj1028.decls)) && (car(obj1028.decls) instanceof J2SDeclInit)) { let obj1029 = car(obj1028.decls); return obj1029.val instanceof J2SDProducer; } } } } }
);let arrowParams = ((args) => { return map(((p, idx) => { if (tokenp(p)) { let loc = tokenLoc(p); return new J2SDecl({'loc': loc,'id': tokenValue(p),'binder': 'param'}); } else if (p instanceof J2SAssig) { let obj1030 = p; { let obj1031 = obj1030.lhs; return new J2SDeclInit({'val': obj1030.rhs,'loc': obj1030.loc,'id': obj1031.id,'binder': 'param'}); } } else if (p instanceof J2SUnresolvedRef) { let obj1032 = p; return new J2SDecl({'loc': obj1032.loc,'id': obj1032.id,'binder': 'param'}); } else if ((p instanceof J2SObjInit) || (p instanceof J2SArray)) { let obj1033 = p; { let id = stringtosymbol("%"+idx); return new J2SDeclDestructure({'loc': obj1033.loc,'id': id,'_scmid': id,'binder': 'param','literal': p}); } } else if (p instanceof J2SDecl) return p; else if (arrowParamBindExitDesctructurep(p)) { let obj1034 = p; { let obj1035 = obj1034.stmt; { let obj1036 = car(obj1035.nodes); return car(obj1036.decls).duplicate({'binder': 'param'}); } } } else return parseNodeError("Unexpected token in arrow parameter list", p); }
), args, iota(length(args))); }
);let arrowBody = ((params, args) => { return arrowBodyParamsDefvalBlock(params, args, ((peekTokenType() === 'LBRACE') ? (funBody(params, args, currentMode)) : ((((expr, endloc) => { { let obj1037 = expr; return funBodyParamsDefvalBlock(obj1037.loc, endloc, params, destructureFunParams(params, args, new J2SBlock({'loc': obj1037.loc,'endloc': endloc,'nodes': list(new J2SReturn({'loc': obj1037.loc,'expr': expr}))}))); } })(assigExpr(false, false, false), tokenLoc(peekToken(), -1)))))); }
);let arrowBodyParamsDefvalBlock = ((params, args, body) => { const loop$ = ((function loop(args) { if (nullp(args)) return body; else if (arrowParamBindExitDesctructurep(car(args))) return arrowParamDefval(car(args), loop(cdr(args))); else return loop(cdr(args)); })(args)); return loop$; });let arrowParamDefval = ((p, body) => { let assigtodecl = ((node) => { { let obj1038 = node; if (obj1038.expr instanceof J2SAssig) { let obj1039 = obj1038.expr; { let obj1040 = obj1039.lhs; return new J2SDeclInit({'loc': obj1039.loc,'id': obj1040.id,'binder': 'let','val': obj1039.rhs}); } } } }
);{ let obj1041 = p; { let obj1042 = obj1041.stmt; { let obj1043 = car(obj1042.nodes); { let obj1044 = car(obj1043.decls); { let obj1045 = obj1044.val; { let decl = (((rhs, lhs, test, then, $$else, val) => { return cadr(obj1043.decls).duplicate({'val': val}); })(new J2SUndefined({'loc': obj1041.loc}), new J2SRef({'loc': obj1041.loc,'decl': car(obj1043.decls)}), new J2SBinary({'loc': obj1041.loc,'op': '===','lhs': lhs,'rhs': rhs}), obj1045.expr, new J2SRef({'loc': obj1041.loc,'decl': car(obj1043.decls)}), new J2SCond({'loc': obj1041.loc,'test': test,'then': then,'else': $$else}))), args = new J2SBlock({'loc': obj1041.loc,'endloc': obj1042.endloc,'nodes': list(new J2SVarDecls({'loc': obj1041.loc,'decls': filterMap(assigtodecl, cdr(obj1042.nodes))}), body)}); { let obj1046 = body; return new J2SBlock({'loc': obj1046.loc,'endloc': obj1046.endloc,'nodes': list(new J2SVarDecls({'loc': obj1046.loc,'decls': cons(decl, cddr(obj1043.decls))}), args)}); } } } } } } } }
);let arrowFunction = ((rt, args, loc) => { consumeAny$();{ let params = arrowParams(args); return new J2SArrow({'idthis': '%','loc': loc,'name': '','mode': ((currentMode === 'hopscript') ? ('hopscript') : ('strict')),'params': params,'rutype': rt,'body': arrowBody(params, args),'vararg': restParams(params)}); } }
);let arrowTypescriptFunction = ((token, expr) => { consumeAny$();if (expr instanceof J2SUnresolvedRef) { let obj1047 = expr; { let id = makeToken('ID', obj1047.id, obj1047.loc), rt = typescriptType(); tokenPushBack$(id);tokenPushBack$(popOpenToken(token));{ let [params, args] = functionParams(false); consumeToken$('=>');return new J2SArrow({'idthis': '%','loc': obj1047.loc,'name': '','mode': 'strict','params': params,'body': arrowBody(params, args),'rutype': rt,'vararg': restParams(params)}); } } } else return parseNodeError("identifier expected", expr); }
);let restParams = ((params) => { if (pairp(params)) if (declUsageHasp(car(lastPair(params)), ['rest'])) return 'rest'; }
);let loctofunname = ((pref, loc) => { return stringtosymbol("a@"+pref+":"+locFilename(loc)); }
);let $$function = ((declarationp, token, methodof) => { let loc = tokenLoc(token); { let gen = ((peekTokenType() === '*') ? ((consumeAny$(), '*')) : undefined), id = (((declarationp) || (['ID']?.includes(peekTokenType()))) ? (consumeAny$()) : undefined); { let [params, args] = functionParams(false); { let ty = optType(), body = funBody(params, args, currentMode), mode = (javascriptMode(body)) || (currentMode); if (declarationp) return (((val, decl) => { val = new J2SFun(); decl = new J2SDeclFun(); Object.assign(val, {'loc': loc,'src': funSrc,'thisp': newDeclThis(loc),'params': params,'name': tokenValue(id),'mode': mode,'generator': gen,'ismethodof': methodof,'rutype': ty,'body': body,'vararg': restParams(params)}); Object.assign(decl, {'loc': loc,'writable': (mode !== 'hopscript') && (!typescript),'usage': ((mode === 'hopscript') ? (null) : (['assig'])),'id': tokenValue(id),'val': val}); return decl; } )(undefined, undefined)); else if (id) return (((fun, decl) => { fun = new J2SFun(); decl = new J2SDeclFun(); Object.assign(fun, {'loc': loc,'src': funSrc,'decl': decl,'mode': mode,'generator': gen,'name': tokenValue(id),'thisp': newDeclThis(loc),'params': params,'ismethodof': methodof,'vararg': restParams(params),'body': body}); Object.assign(decl, {'loc': tokenLoc(id),'id': tokenValue(id),'writable': false,'usage': null,'expression': true,'val': fun}); return fun; } )(undefined, undefined)); else return new J2SFun({'loc': loc,'src': funSrc,'name': loctofunname("fun", loc),'mode': mode,'generator': gen,'thisp': newDeclThis(loc),'params': params,'vararg': restParams(params),'ismethodof': methodof,'body': body}); } } } });let serviceCreate = ((token, id, params, args, body, mode, register, declarationp, importp) => { let loc = tokenLoc(token); if (declarationp) return (((val, decl) => { val = new J2SSvc(); decl = new J2SDeclSvc(); Object.assign(val, {'loc': loc,'new-target': 'not-a-ctor','register': register,'import': importp,'thisp': newDeclThis(loc),'params': params,'vararg': restParams(params),'name': tokenValue(id),'init': new J2SNop({'loc': loc}),'mode': mode,'path': tokenValue(id),'body': body,'decl': decl}); Object.assign(decl, {'loc': loc,'id': tokenValue(id),'writable': false,'usage': null,'val': val}); return decl; } )(undefined, undefined)); else if (id) return (((svc, decl) => { svc = new J2SSvc(); decl = new J2SDeclFun(); Object.assign(svc, {'loc': tokenLoc(id),'new-target': 'not-a-ctor','register': register,'import': importp,'decl': decl,'thisp': newDeclThis(loc),'params': params,'vararg': restParams(params),'name': tokenValue(id),'init': new J2SNop({'loc': loc}),'mode': mode,'path': tokenValue(id),'body': body}); Object.assign(decl, {'loc': tokenLoc(id),'id': tokenValue(id),'writable': false,'usage': null,'expression': true,'val': svc}); return svc; } )(undefined, undefined)); else return new J2SSvc({'loc': loc,'newTarget': 'not-a-ctor','register': register,'import': importp,'thisp': newDeclThis(loc),'params': params,'vararg': restParams(params),'name': gensym(),'init': new J2SNop({'loc': loc}),'mode': mode,'body': body}); });let serviceImport = ((token, id, params, args, declarationp) => { let loc = tokenLoc(id); if (!(nullp(params))) parseNodeError("Imported service must not declare parameters", car(params));{ let body = new J2SBlock({'loc': loc,'endloc': loc,'nodes': list(new J2SNop({'loc': loc}))}), init = new J2SNop({'loc': loc}); return serviceCreate(token, id, params, args, body, 'hopstrict', false, declarationp, true); } });let serviceImplement = ((token, id, params, args, declarationp) => { { let body = funBody(params, args, 'strict'), mode = (((javascriptMode(body) === 'hopscript') ? ('hopscript') : ('strict'))); return serviceCreate(token, id, params, args, body, mode, true, declarationp, false); } }
);let consumeModulePath$ = (() => { switch (peekTokenType()) { case 'STRING': { let mod = consumeAny$(), url = tokenValue(mod); return [url, new J2SUndefined({'loc': tokenLoc(mod)})]; } break; case 'ID': { let id = consumeAny$(); if (tokenValue(id) === 'hop') { consumeToken$('DOT');return [(((mod) => { return stringAppend("hop:", symboltostring(tokenValue(mod))); })(consumeToken$('ID'))), new J2SUndefined({'loc': tokenLoc(id)})]; }
 else return parseTokenError("Illegal import path (should be hop.xxx)", id); } break; case 'DOLLAR': if ((tildeLevel > 0)) return withDollar((() => { { let ignore = pushOpenToken(consumeAny$()), expr = expression(false, false); popOpenToken(consumeToken$('RBRACE'));return ["", new J2SDollar({'loc': tokenLoc(ignore),'node': expr})]; } }
)); else return parseTokenError("Illegal import path", consumeAny$()); break; default: return parseTokenError("Illegal import path", consumeAny$()); } }
);let $$import = ((token) => { esModule = true;{ const loop$ = ((function loop(first, types) { switch (peekTokenType()) { case 'type': consumeAny$();return loop(first, true); break; case 'LBRACE': { let lst = importNameList(); if (nullp(lst)) return parseTokenError("Illegal empty import", token); else { let fro = consumeToken$('ID'); if (tokenValue(fro) === 'from') { let [path, dollarpath] = consumeModulePath$(); return new J2SImport({'loc': tokenLoc(token),'names': lst,'path': path,'dollarpath': dollarpath,'types': types}); } else return parseTokenError("Illegal import, \"from\" expected", fro); } } break; case 'STRING': if (!first) return parseTokenError("Illegal import, unexpected string", consumeAny$()); else { let path = consumeAny$(), loc = tokenLoc(token); return new J2SImport({'names': null,'loc': loc,'path': tokenValue(path),'dollarpath': new J2SUndefined({'loc': loc}),'types': types}); } break; case '*': consumeAny$();if (peekTokenIdp('as')) { let as = consumeAny$(), id = consumeToken$('ID'), fro = consumeToken$('ID'); if (tokenValue(fro) === 'from') { let [path, dollarpath] = consumeModulePath$(); { let impns = new J2SImportName({'loc': tokenLoc(id),'id': '*','alias': tokenValue(id)}); return new J2SImport({'loc': tokenLoc(token),'names': list(impns),'path': path,'dollarpath': dollarpath,'types': types}); } } else return parseTokenError("Illegal import, \"from\" expected", fro); } else return parseTokenError("Illegal import, \"as\" expected", consumeAny$()); break; case 'LPAREN': if (!first) return parseTokenError("Illegal import, unexpected parenthesis", consumeAny$()); else { consumeAny$();{ let path = expression(false, false); consumeToken$('RPAREN');return new J2SStmtExpr({'loc': tokenLoc(token),'expr': new J2SImportDynamic({'loc': tokenLoc(token),'path': path})}); } }
 break; case 'ID': if (!first) return parseTokenError("Illegal import, duplicated default", consumeAny$()); else { let token = consumeAny$(), id = tokenValue(token), sep = consumeAny$(); if ((tokenType(sep) === 'ID') && (tokenValue(sep) === 'from')) { let path = consumeToken$('STRING'), loc = tokenLoc(token), impnm = new J2SImportName({'loc': loc,'id': 'default','alias': id}); return new J2SImport({'loc': loc,'names': list(impnm),'path': tokenValue(path),'dollarpath': new J2SUndefined({'loc': loc}),'types': types}); } else if (tokenType(sep) === 'COMMA') { let imp = loop(false, types), impnm = new J2SImportName({'loc': tokenLoc(sep),'id': 'default','alias': id}); { let obj1048 = imp; { let loc = tokenLoc(token), defi = new J2SImport({'loc': loc,'names': list(impnm),'dollarpath': obj1048.dollarpath,'path': obj1048.path,'types': types}); return new J2SSeq({'loc': loc,'nodes': list(defi, imp)}); } } } else return parseTokenError("Illegal import", sep); } break; case 'DOT': tokenPushBack$(token);return expressionStatement(); break; default: return parseTokenError("Illegal import", consumeAny$()); } })(true, false)); return loop$; } }
);let importNameList = (() => { consumeAny$();{ const loop$ = ((function loop() { { let token = consume2$('ID', 'default'), loc = tokenLoc(token), id = tokenValue(token), alias = ((peekTokenIdp('as')) ? ((consumeAny$(), tokenValue(consumeToken$('ID')))) : (id)), impnm = new J2SImportName({'loc': loc,'id': id,'alias': alias}), next = consumeAny$(); switch (tokenType(next)) { case 'RBRACE': return list(impnm); break; case 'COMMA': if (peekTokenType() === 'RBRACE') { consumeAny$();return list(impnm); }
 else return cons(impnm, loop()); break; default: return parseTokenError("Illegal import", next); } } })()); return loop$; } }
);let exportDecl = ((decl) => { { let obj1049 = decl; obj1049.scope = 'export';{ let x = new J2SExport({'loc': obj1049.loc,'id': obj1049.id,'alias': obj1049.id,'decl': decl}); obj1049.export = x;exports = cons(x, exports); }return decl; } }
);let exportFrom = ((token, ids, aliases) => { let loc = tokenLoc(token); if (peekTokenIdp('from')) { let loc = tokenLoc(consumeAny$()); { let [path, dollarpath] = consumeModulePath$(); { let i = new J2SImport({'names': null,'loc': loc,'path': path,'dollarpath': dollarpath}), x = map(((id, a) => { return new J2SRedirect({'loc': loc,'id': id,'alias': a,'import': i}); }
), ids, aliases); exports = append(x, exports);return i; } } } else { let x = map(((id, a) => { return new J2SExport({'loc': loc,'id': id,'alias': a}); }
), ids, aliases); exports = append(x, exports);return new J2SNop({'loc': loc}); } });let $$export = ((token) => { esModule = true;switch (peekTokenType()) { case 'var':case 'let':case 'const':case 'class':case 'record':{ let stmt = statement(); { let obj1050 = stmt; obj1050.decls = map(exportDecl, obj1050.decls); }return stmt; }break; case 'LBRACE': { let token = consumeAny$(); if (peekTokenType() === 'RBRACE') { consumeAny$();return new J2SNop({'loc': tokenLoc(token)}); }
 else { const loop$ = ((function loop(ids, aliases) { { let tid = consume2$('ID', 'default'), id = tokenValue(tid), alias = ((peekTokenIdp('as')) ? ((consumeAny$(), (((talias) => { switch (tokenType(talias)) { case 'default': return 'default'; break; case 'ID': return tokenValue(talias); break; default: return parseTokenError("Illegal export", talias); } })(consumeAny$())))) : (id)); switch (peekTokenType()) { case 'RBRACE': return exportFrom(consumeAny$(), cons(id, ids), cons(alias, aliases)); break; case 'COMMA': consumeAny$();if (peekTokenType() === 'RBRACE') return exportFrom(consumeAny$(), cons(id, ids), cons(alias, aliases)); else return loop(cons(id, ids), cons(alias, aliases)); break; default: return parseTokenError("Illegal export", token); } } })(null, null)); return loop$; } } break; case 'function': return exportDecl(statement()); break; case 'default': { let loc = tokenLoc(consumeAny$()), val = expression(false, false); return (((expo, decl, ref) => { expo = new J2SExport(); decl = new J2SDeclInit(); ref = new J2SRef(); Object.assign(expo, {'loc': loc,'id': 'default','alias': 'default','index': 0,'decl': decl}); Object.assign(decl, {'loc': loc,'id': 'default','export': expo,'binder': 'let','scope': 'export','val': val}); Object.assign(ref, {'loc': loc,'decl': decl}); return (exports = cons(expo, exports), new J2SSeq({'loc': loc,'nodes': list(new J2SVarDecls({'loc': loc,'decls': list(decl)}))})); } )(undefined, undefined, undefined)); } break; case '*': { let _ = consumeToken$('*'), id = consumeToken$('ID'); switch (tokenValue(id)) { case 'as': { let alias = consumeToken$('ID'), fro = consumeToken$('ID'); if (tokenValue(fro) === 'from') { let [path, dollarpath] = consumeModulePath$(); { let i = new J2SImport({'loc': tokenLoc(token),'path': path,'dollarpath': dollarpath,'names': null}), x = new J2SRedirectNamespace({'loc': tokenLoc(token),'id': gensym('*'),'alias': tokenValue(alias),'import': i}); exports = cons(x, exports);return i; } } else return parseTokenError("Illegal export, \"from\" expected", fro); } break; case 'from': { let [path, dollarpath] = consumeModulePath$(); { let i = new J2SImport({'loc': tokenLoc(token),'path': path,'dollarpath': dollarpath,'names': null}), x = new J2SRedirectNamespace({'loc': tokenLoc(token),'id': gensym('*'),'alias': '*','import': i}); exports = cons(x, exports);return i; } } break; default: return parseTokenError("Illegal export, \"from\" expected", id); } } break; case 'type': typeDeclList();return new J2SNop({'loc': tokenLoc(token)}); break; case 'ID': { let tok = consumeAny$(), next = peekTokenType(); if (tokenValue(tok) === 'async') if (next === 'function') return exportDecl(asyncDeclaration(token)); else if (next === '=>') return exportDecl(asyncDeclaration(token)); else return parseTokenError("Illegal export declaration", peekToken()); else return parseTokenError("Illegal export declaration", peekToken()); } break; default: return parseTokenError("Illegal export declaration", peekToken()); } }
);let $service = ((declarationp) => { { let token = consumeToken$('ID'), id = (((declarationp) || (peekTokenType() === 'ID')) ? (consumeToken$('ID')) : undefined); { let [params, args] = functionParams(true); if (peekTokenType() === 'LBRACE') if (any(((p) => { return !p; }
), params)) return parseTokenError("Illegal service declaration", token); else return serviceImplement(token, id, params, args, declarationp); else if (id) if (any(((p) => { return !p; }
), params)) return parseTokenError("Illegal service import", token); else return serviceImport(token, id, params, args, declarationp); else { let loc = tokenLoc(token), fun = new J2SUnresolvedRef({'loc': loc,'id': 'service'}); return new J2SCall({'loc': loc,'fun': fun,'protocol': argsProtocol(args),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': args}); } } } }
);let consumeParam$ = ((idx, maybeExprp) => { switch (peekTokenType()) { case 'ID': { let token = consumeAny$(), loc = tokenLoc(token), opt = (((typescript) && (peekTokenType() === '?')) ? ((consumeAny$(), true)) : undefined), hint = null, typ = optType(); if (peekTokenType() === '=') { consumeAny$();return [new J2SDeclInit({'binder': 'param','val': assigExpr(false, false, false),'loc': loc,'id': tokenValue(token),'utype': typ,'hint': hint,'optional': true}), false]; }
 else return [new J2SDecl({'binder': 'param','loc': loc,'id': tokenValue(token),'utype': typ,'hint': hint,'optional': opt}), false]; } break; case 'LBRACE': { let id = stringtosymbol("%"+idx), loc = tokenLoc(peekToken()), lit = objectLiteral(true); if (peekTokenType() === '=') { consumeAny$();{ let expr = assigExpr(false, false, false), arg = new J2SDeclInitDestructure({'binder': 'param','loc': loc,'id': id,'val': expr,'_scmid': id,'literal': lit}); return [arg, lit]; } }
 else { let arg = new J2SDeclDestructure({'binder': 'param','loc': loc,'id': id,'_scmid': id,'literal': lit}); return [arg, lit]; } } break; case 'LBRACKET': { let id = stringtosymbol("%"+idx), loc = tokenLoc(peekToken()), lit = arrayLiteral(false, false, 'array'); return [new J2SDeclDestructure({'binder': 'param','loc': loc,'id': id,'_scmid': id,'literal': lit}), lit]; } break; default: if (maybeExprp) return [false, assigExpr(false, false, false)]; else return parseError("Unexpected token in formal parameter list", consumeAny$()); } }
);let consumeRestParam$ = (() => { { let token = consumeToken$('ID'), loc = tokenLoc(token); return new J2SDeclRest({'binder': 'param','loc': loc,'usage': ['rest'],'id': tokenValue(token)}); } }
);let functionParams = ((maybeExprp) => { pushOpenToken(consumeToken$('LPAREN'));switch (peekTokenType()) { case 'RPAREN': popOpenToken(consumeAny$());return [null, null]; break; case 'DOTS': consumeAny$();{ let param = consumeRestParam$(); popOpenToken(consumeToken$('RPAREN'));return [list(param), list(false)]; } break; default: { let token = peekToken(); { let [param, arg] = consumeParam$(0, maybeExprp); if (!param) return parseTokenError("Illegal function parameter", token); else { const loop$ = ((function loop(revParams, revArgs, idx) { if (peekTokenType() === 'COMMA') { let command = consumeAny$(), token = peekToken(); switch (peekTokenType()) { case 'DOTS': consumeAny$();{ let param = consumeRestParam$(); popOpenToken(consumeToken$('RPAREN'));return [reverse$(cons(param, revParams)), reverse$(cons(false, revArgs))]; } break; case 'RPAREN': popOpenToken(consumeToken$('RPAREN'));return [reverse$(revParams), reverse$(revArgs)]; break; default: { let [param, arg] = consumeParam$(idx, maybeExprp); if (!param) return parseTokenError("Illegal parameter", token); else return loop(cons(param, revParams), cons(arg, revArgs), (idx + 1)); } } } else { popOpenToken(consumeToken$('RPAREN'));return [reverse$(revParams), reverse$(revArgs)]; }
 })(list(param), list(arg), 1)); return loop$; } } } } }
);let paramDefval = ((p) => { if (p instanceof J2SDeclInit) { let obj1051 = p; if (!((obj1051.val instanceof J2SUndefined) || ((obj1051.val instanceof J2SUnresolvedRef) && (((obj1052 => { return obj1052.id === 'undefined'; })(obj1051.val)))))) { let rhs = new J2SUndefined({'loc': obj1051.loc}), lhs = new J2SRef({'loc': obj1051.loc,'decl': p}), test = new J2SBinary({'loc': obj1051.loc,'op': '===','lhs': lhs,'rhs': rhs}), then = new J2SStmtExpr({'loc': obj1051.loc,'expr': new J2SAssig({'loc': obj1051.loc,'lhs': lhs.duplicate({}),'rhs': obj1051.val})}), $$else = new J2SNop({'loc': obj1051.loc}); return new J2SIfArgDefVal({'loc': obj1051.loc,'test': test,'then': then,'else': $$else}); } } }
);let funBodyParamsDefval = ((params) => { return filterMap(paramDefval, params); }
);let funBodyParamsDefvalBlock = ((loc, endloc, params, body) => { let defvals = funBodyParamsDefval(params); if (pairp(defvals)) return new J2SBlock({'loc': loc,'endloc': endloc,'nodes': append(defvals, list(body))}); else return body; });let funBody = ((params, args, mode) => { let cmode = currentMode, cplugins = plugins; currentMode = mode;if (peekTokenType() === ':') { consumeAny$();typescriptType(); }
try { let token = pushOpenToken(consumeToken$('LBRACE')); { let loc = currentLoc(); { const loop$ = ((function loop(revSes, first) { if (peekTokenType() === 'RBRACE') { let etoken = consumeAny$(), loc = tokenLoc(token), endloc = tokenLoc(etoken); popOpenToken(etoken);return funBodyParamsDefvalBlock(loc, endloc, params, destructureFunParams(params, args, new J2SBlock({'loc': loc,'endloc': endloc,'nodes': reverse$(revSes)}))); } else { let tok = peekToken(), el = sourceElement(); if ((first) && ((el instanceof J2SString) || ((el instanceof J2SStmtExpr) && (((obj1053 => { return obj1053.expr instanceof J2SString; })(el)))))) { sourceElementMode$(el);return loop(cons(el, revSes), true); }
 else return loop(cons(el, revSes), false); } })(null, true)); return loop$; } } } finally { currentMode = cmode;plugins = cplugins; }
 });let clazz = ((declarationp) => { { let loc = currentLoc(), token = consumeToken$('class'), id = (((declarationp) || (peekTokenType() === 'ID')) ? (consumeToken$('ID')) : undefined), cname = ((id) ? (tokenValue(id)) : undefined), $$extends = ((peekTokenType() === 'extends') ? ((consumeToken$('extends'), assigExpr(false, false, false))) : (new J2SUndefined({'type': 'undefined','loc': loc}))), lbrace = pushOpenToken(consumeToken$('LBRACE')); { const loop$ = ((function loop(revSes) { switch (peekTokenType()) { case 'RBRACE': { let etoken = consumeAny$(), ses = reverse$(revSes); popOpenToken(etoken);{ let clazz = new J2SClass({'endloc': tokenLoc(etoken),'name': cname,'loc': tokenLoc(token),'super': $$extends,'elements': ses,'type': 'class'}); forEach(((ce) => { { let obj1054 = ce; return obj1054.clazz = clazz; } }
), ses);if (!declarationp) return clazz; else { let decl = new J2SDeclClass({'loc': tokenLoc(id),'id': tokenValue(id),'writable': (currentMode !== 'hopscript') && (!typescript),'usage': null,'binder': 'let','val': clazz}); { let obj1055 = clazz; obj1055.decl = decl; }return new J2SVarDecls({'loc': loc,'decls': list(decl)}); } } } break; case 'SEMICOLON': consumeAny$();return loop(revSes); break; default: return loop(cons(classElement(cname, !($$extends instanceof J2SUndefined)), revSes)); } })(null)); return loop$; } } }
);let record = (() => { { let loc = currentLoc(), token = consumeAny$(), id = consumeToken$('ID'), cname = tokenValue(id), $$extends = ((peekTokenType() === 'extends') ? ((consumeToken$('extends'), (((tid) => { return new J2SUnresolvedRef({'loc': tokenLoc(tid),'id': tokenValue(tid)}); })(consumeToken$('ID'))))) : (new J2SUndefined({'type': 'undefined','loc': loc}))), lbrace = pushOpenToken(consumeToken$('LBRACE')); { const loop$ = ((function loop(revSes) { switch (peekTokenType()) { case 'RBRACE': { let etoken = consumeAny$(), ses = reverse$(revSes); popOpenToken(etoken);return (((clazz, decl) => { clazz = new J2SRecord(); decl = new J2SDeclClass(); Object.assign(clazz, {'endloc': tokenLoc(etoken),'name': cname,'loc': tokenLoc(token),'super': $$extends,'elements': ses,'decl': decl}); Object.assign(decl, {'loc': tokenLoc(id),'id': tokenValue(id),'writable': false,'usage': null,'binder': 'let-opt','val': clazz}); return (forEach(((ce) => { { let obj1056 = ce; return obj1056.clazz = clazz; } }
), ses), new J2SVarDecls({'loc': loc,'decls': list(decl)})); } )(undefined, undefined)); } break; case 'SEMICOLON': consumeAny$();return loop(revSes); break; default: return loop(cons(classElement(cname, !($$extends instanceof J2SUndefined)), revSes)); } })(null)); return loop$; } } }
);let classElement = ((cname, superp) => { if (peekTokenIdp('static')) { let tok = consumeToken$('ID'); if (peekTokenIdp('async')) { consumeToken$('ID');return classMethod(true, true, cname, superp); }
 else if (peekTokenType() === 'LPAREN') { tokenPushBack$(tok);return classMethod(false, false, cname, superp); }
 else return classMethod(false, true, cname, superp); } else if (peekTokenIdp('async')) { consumeToken$('ID');return classMethod(true, false, cname, superp); }
 else return classMethod(false, false, cname, superp); }
);let methodName = ((name, cname, loc) => { { let met = ((name instanceof J2SString) ? (((obj1057 => { return obj1057.val; })(name))) : ("met")), fun = ((symbolp(cname)) ? ("a."+cname) : (met)); return loctofunname(fun, loc); } }
);let newTarget = ((name) => { if (name instanceof J2SString) { let obj1058 = name; if (obj1058.val === "constructor") return 'unknown'; else return 'not-a-ctor'; } else return 'not-a-ctor'; }
);let classMethod = ((asyncp, staticp, cname, superp) => { { let loc = tokenLoc(peekToken()), gen = ((peekTokenType() === '*') ? ((consumeAny$(), '*')) : undefined), nameOrGet = propertyName(false, true), ty = optType(); if (nameOrGet instanceof J2SNode) switch (peekTokenType()) { case '=': consumeAny$();{ let prop = new J2SDataPropertyInit({'loc': loc,'name': nameOrGet,'val': assigExpr(false, false, false)}); return new J2SClassElement({'loc': loc,'static': staticp,'type': ty,'prop': prop}); } break; case 'SEMICOLON': { let prop = new J2SPropertyInit({'loc': loc,'name': nameOrGet}); return new J2SClassElement({'loc': loc,'static': staticp,'type': ty,'prop': prop}); } break; default: { let [params, args] = functionParams(false); { let body = funBody(params, args, 'strict'), fun = new J2SFun({'loc': loc,'newTarget': newTarget(nameOrGet),'src': funSrc,'thisp': newDeclThis(loc),'params': params,'mode': 'strict','name': methodName(nameOrGet, cname, loc),'generator': gen,'rutype': ty,'body': body,'ismethodof': superp,'vararg': restParams(params)}), prop = new J2SMethodPropertyInit({'loc': loc,'name': nameOrGet,'val': ((asyncp) ? (asynctogenerator(fun)) : (fun))}); return new J2SClassElement({'loc': loc,'static': staticp,'prop': prop}); } } } else if (peekTokenType() === 'LPAREN') { let [params, args] = functionParams(false); { let body = funBody(params, args, 'strict'), fun = new J2SFun({'loc': loc,'newTarget': newTarget(newTarget(nameOrGet)),'src': funSrc,'thisp': newDeclThis(loc),'params': params,'mode': 'strict','name': methodName(nameOrGet, cname, loc),'generator': gen,'rutype': ty,'body': body,'ismethodof': superp,'vararg': restParams(params)}), prop = new J2SMethodPropertyInit({'loc': loc,'name': new J2SString({'loc': tokenLoc(nameOrGet),'val': symboltostring(tokenValue(nameOrGet))}),'val': ((asyncp) ? (asynctogenerator(fun)) : (fun))}); return new J2SClassElement({'loc': loc,'static': staticp,'prop': prop}); } } else { let name = propertyName(false, true); { let [params, args] = functionParams(false); { let body = funBody(params, args, 'strict'), fun = new J2SFun({'loc': loc,'src': funSrc,'thisp': newDeclThis(loc),'params': params,'mode': 'strict','name': methodName(nameOrGet, cname, loc),'generator': gen,'rutype': ty,'body': body,'ismethodof': superp,'vararg': restParams(params)}), prop = new J2SAccessorPropertyInit({'loc': loc,'name': name,'get': ((tokenValue(nameOrGet) === 'get') ? (((asyncp) ? (asynctogenerator(fun)) : (fun))) : (new J2SUndefined({'loc': loc}))),'set': ((tokenValue(nameOrGet) === 'set') ? (((asyncp) ? (asynctogenerator(fun)) : (fun))) : (new J2SUndefined({'loc': loc})))}); return new J2SClassElement({'loc': loc,'static': staticp,'prop': prop}); } } } } }
);let expression = ((inForInitp, destructuringp) => { let assig = assigExpr(inForInitp, destructuringp, false); { const loop$ = ((function loop(revExprs) { if (peekTokenType() === 'COMMA') { consumeAny$();return loop(cons(assigExpr(inForInitp, destructuringp, false), revExprs)); }
 else if (nullp(cdr(revExprs))) return car(revExprs); else { let exprs = reverse$(revExprs); { let obj1059 = car(exprs); return new J2SSequence({'loc': obj1059.loc,'exprs': exprs}); } } })(list(assig))); return loop$; } });let assigOperatorp = ((x) => { switch (x) { case '=':case '*=':case '/=':case '%=':case '+=':case '-=':case '<<=':case '>>=':case '>>>=':case '&=':case '^=':case 'BIT_OR=':case '**=':case '??=':case 'OR=':case '&&=':return true;break; default: return false; } }
);let assigExpr = ((inForInitp, destructuringp, spreadp) => { let withOut$ = ((op$) => { { let s$ = symboltostring(op$), s$Length = s$.length, s = s$.substring(0, s$Length - 1), op = stringtosymbol(s); return op; } }
);{ let lhs = condExpr(inForInitp, destructuringp, spreadp); if (assigOperatorp(peekTokenType())) { let op = consumeAny$(), rhs = assigExpr(inForInitp, false, false); switch (tokenType(op)) { case '=': if ((lhs instanceof J2SArray) || (lhs instanceof J2SObjInit)) { let loc = tokenLoc(op), endloc = loc, objectp = lhs instanceof J2SObjInit, decl = new J2SDeclInit({'loc': loc,'binder': 'var','usage': ['init', 'ref', 'get'],'val': new J2SUndefined({'type': 'undefined','loc': loc}),'id': gensym('%obj')}), inits = j2sDestructure(lhs, decl, false), bindings = filter(((i) => { return i instanceof J2SDecl; }
), inits), nodes = filterMap(((i) => { if (!(i instanceof J2SDecl)) return new J2SStmtExpr({'loc': loc,'expr': i}); }
), inits); { let obj1060 = decl; obj1060.binder = 'let-opt';obj1060.val = new J2SDProducer({'loc': loc,'size': ((objectp) ? (-1) : (length(inits))),'type': ((objectp) ? ('object') : ('array')),'decl': decl,'expr': rhs}); }return new J2SBindExit({'loc': loc,'lbl': false,'stmt': new J2SBlock({'loc': loc,'endloc': endloc,'nodes': cons(new J2SVarDecls({'loc': loc,'decls': cons(decl, bindings)}), append(nodes, list(new J2SStmtExpr({'loc': loc,'expr': new J2SRef({'loc': loc,'type': 'unknown','decl': decl})}))))})}); } else return new J2SAssig({'loc': tokenLoc(op),'lhs': lhs,'rhs': rhs}); break; case '??=': return new J2SBinary({'op': '??','loc': tokenLoc(op),'lhs': dupExpr(lhs),'rhs': new J2SAssig({'loc': tokenLoc(op),'lhs': lhs,'rhs': rhs})}); break; case 'OR=': return new J2SBinary({'op': 'OR','loc': tokenLoc(op),'lhs': dupExpr(lhs),'rhs': new J2SAssig({'loc': tokenLoc(op),'lhs': lhs,'rhs': rhs})}); break; case '&&=': return new J2SBinary({'op': '&&','loc': tokenLoc(op),'lhs': dupExpr(lhs),'rhs': new J2SAssig({'loc': tokenLoc(op),'lhs': lhs,'rhs': rhs})}); break; default: return new J2SAssigOp({'loc': tokenLoc(op),'lhs': lhs,'op': withOut$(tokenType(op)),'rhs': rhs}); } } else return lhs; } }
);let condExpr = ((inForInitp, destructuringp, spreadp) => { let expr = binaryExpr(inForInitp, destructuringp, spreadp), token = peekToken(); if (tokenType(token) === '?') { let ignoreP = consumeAny$(), then = assigExpr(false, false, false), ignoreColon = consume$(':'), $$else = assigExpr(inForInitp, false, false); return new J2SCond({'loc': tokenLoc(token),'test': expr,'then': then,'else': $$else}); } else return expr; });let opLevel = ((op) => { switch (op) { case '??': return 5; break; case 'OR': return 6; break; case '&&': return 7; break; case 'BIT_OR': return 8; break; case '^': return 9; break; case '&': return 10; break; case '==':case '!=':case '===':case '!==':return 11;break; case '<':case '>':case '<=':case '>=':case 'instanceof':case 'in':case 'as':return 12;break; case '<<':case '>>':case '>>>':return 13;break; case '+':case '-':return 14;break; case '*':case '/':case '%':case '**':return 15;break; default: return false; } }
);let isBinaryp = ((expr, ops) => { if (expr instanceof J2SBinary) { let obj1061 = expr; return ops?.includes(obj1061.op); } }
);let binaryExpr = ((inForInitp, destructuringp, spreadp) => { const binaryAux$ = ((function binaryAux(level) { if ((level > 15)) return unary(destructuringp, spreadp); else { const loop$ = ((function loop(expr) { { let typ = peekTokenType(), newLevel = opLevel(typ); if ((typ === 'as') && (typescript)) { let as = consumeAny$(); { let ty = typescriptType(); return new J2SBinary({'loc': tokenLoc(as),'type': ty,'op': 'as','lhs': expr,'rhs': new J2SUndefined({'loc': tokenLoc(as)})}); } } else if (typ === '**') { let token = consumeAny$(); if (expr instanceof J2SBinary) { let obj1062 = expr; obj1062.rhs = new J2SBinary({'loc': tokenLoc(token),'op': '**','lhs': obj1062.rhs,'rhs': binaryAux(level)});return expr; } else if ((expr instanceof J2SNumber) && (((obj1063 => { return (obj1063.val < 0); })(expr)))) return parseTokenError("Unexpected token", token); else return new J2SBinary({'loc': tokenLoc(token),'op': '**','lhs': expr,'rhs': binaryAux(level)}); } else if ((inForInitp) && (typ === 'in')) return expr; else if (!newLevel) return expr; else if (newLevel === level) { let token = consumeAny$(); if (typ === 'OHTML') { let val = tokenValue(token), id = val.substring(1); tokenPushBack$(makeToken('ID', id, tokenLoc(token)));tokenTypeSet$(token, '<'); }{ let rhs = binaryAux((level + 1)); if ((typ === '??') && ((isBinaryp(expr, ['OR', '&&'])) || (isBinaryp(rhs, ['OR', '&&'])))) return parseTokenError("Unexpected token", token); else if ((['OR', '&&']?.includes(typ)) && ((isBinaryp(expr, ['??'])) || (isBinaryp(rhs, ['??'])))) return parseTokenError("Unexpected token", token); else return loop(new J2SBinary({'loc': tokenLoc(token),'lhs': expr,'op': tokenType(token),'rhs': rhs})); } } else return expr; } })(binaryAux((level + 1)))); return loop$; } })(1)); return binaryAux$; });let unary = ((destructuringp, spreadp) => { switch (peekTokenType()) { case '++':case '--':{ let token = consumeAny$(), expr = unary(false, false), loc = tokenLoc(token); if ((expr instanceof J2SUnresolvedRef) || (expr instanceof J2SAccess) || (expr instanceof J2SParen)) { let rhs = new J2SBinary({'loc': loc,'op': tokenType(token),'lhs': expr,'rhs': new J2SNumber({'loc': loc,'val': 1})}); return new J2SPrefix({'loc': loc,'lhs': expr,'rhs': dupExpr(rhs),'op': tokenType(token)}); } else return parseTokenError("Invalid left-hand side expression in prefix operation", token); }break; case 'delete': { let token = consumeAny$(), expr = unary(false, false); return new J2SUnary({'op': tokenType(token),'loc': tokenLoc(token),'expr': expr}); } break; case 'void':case 'typeof':case '~':case '!':{ let token = consumeAny$(); return new J2SUnary({'loc': tokenLoc(token),'op': tokenType(token),'expr': unary(false, false)}); }break; case '+':case '-':{ let token = consumeAny$(), expr = unary(false, false); if (expr instanceof J2SNumber) { let obj1064 = expr; return expr.duplicate({'loc': tokenLoc(token),'val': ((tokenType(token) === '+') ? ((((obj1064.val === 0)) ? (0.0) : (obj1064.val))) : ((((obj1064.val === 0)) ? (-0.0) : (- obj1064.val))))}); } else return new J2SUnary({'loc': tokenLoc(token),'op': tokenType(token),'expr': expr}); }break; default: return postfix(tokenLoc(peekToken()), destructuringp, spreadp); } }
);let postfix = ((loc, destructuringp, spreadp) => { let expr = lhs(loc, destructuringp, spreadp); if (!(atNewLineTokenp())) switch (peekTokenType()) { case '++':case '--':{ let token = consumeAny$(); if ((expr instanceof J2SUnresolvedRef) || (expr instanceof J2SAccess) || (expr instanceof J2SParen)) { let op = tokenType(token), rhs = new J2SBinary({'loc': loc,'op': op,'lhs': expr,'rhs': new J2SNumber({'loc': loc,'val': 1})}); return new J2SPostfix({'loc': loc,'lhs': dupExpr(expr),'rhs': rhs,'op': tokenType(token)}); } else return parseTokenError("Invalid left-hand side expression in postfix operation", token); }break; default: return expr; } else return expr; });let lhs = ((loc, destructuringp, spreadp) => { return accessOrCall(newExpr(loc, destructuringp, spreadp), loc, true); }
);let newExpr = ((loc, destructuringp, spreadp) => { switch (peekTokenType()) { case 'new': { let ignore = consumeAny$(); if (peekTokenType() === 'DOT') { consumeAny$();{ let tok = consumeToken$('ID'); if (tokenValue(tok) === 'target') { let loc = tokenLoc(tok); return new J2SPragma({'loc': loc,'lang': 'javascript','expr': "new.target"}); } else return parseTokenError("Illegal identifier ("+tokenValue(tok)+")", tok); } }
 else { let clazz = newExpr(tokenLoc(ignore), false, false), args = ((peekTokenType() === 'LPAREN') ? ($$arguments()) : (null)); return new J2SNew({'loc': tokenLoc(ignore),'clazz': clazz,'protocol': argsProtocol(args),'args': args}); } } break; case 'yield': return yieldExpr(); break; case 'await': return awaitExpr(); break; default: return accessOrCall(primary(destructuringp, spreadp), loc, false); } }
);let yieldExpr = (() => { let loc = tokenLoc(consumeAny$()), gen = ((peekTokenType() === '*') ? ((consumeAny$(), true)) : undefined); if (((() => { switch (peekTokenType()) { case 'EOF':case 'ERROR':case 'SEMICOLON':case 'RPAREN':case 'RBRACKET':return true;break; default: return false; } })()) || (atNewLineTokenp())) return new J2SYield({'loc': loc,'generator': gen,'await': false,'expr': new J2SUndefined({'loc': loc})}); else { let expr = assigExpr(false, false, false); return new J2SYield({'loc': loc,'generator': gen,'await': false,'expr': expr}); } });let awaitExpr = (() => { { let loc = tokenLoc(consumeAny$()), expr = unary(false, false); return new J2SYield({'loc': loc,'generator': false,'await': true,'expr': expr}); } }
);let tagCallArguments = ((loc) => { { let exprs = templateExpressions(true), strs = filter(((e) => { return e instanceof J2SString; }
), exprs), strse = map(((s) => { { let obj1065 = s; return s.duplicate({'val': tokenValue(j2sEscapeJsString(obj1065.val, inputPort))}); } }
), strs), vals = filterMap(((e) => { if (cellp(e)) return cellRef(e); }
), exprs); return cons(new J2SCall({'loc': loc,'fun': new J2SHopRef({'loc': loc,'id': 'js-template-raw'}),'thisargs': null,'args': list(new J2SArray({'loc': loc,'type': 'array','exprs': strse,'len': length(strs)}), new J2SArray({'loc': loc,'type': 'array','exprs': strs,'len': length(strs)}), new J2SHopRef({'loc': loc,'id': '%this'}))}), vals); } }
);let accessOrCall = ((expr, loc, callAllowedp) => { const loop$ = ((function loop(expr) { switch (peekTokenType()) { case 'LBRACKET': { let ignore = pushOpenToken(consumeAny$()), field = expression(false, false); popOpenToken(consumeToken$('RBRACKET'));return loop(new J2SAccess({'loc': tokenLoc(ignore),'obj': expr,'field': field})); } break; case 'NEWLINE': consumeAny$();return loop(expr); break; case 'DOT': { let ignore = consumeAny$(), field = consumeAny$(), key = tokenType(field), fieldStr = tokenValue(field); if ((key === 'ID') || (key === 'RESERVED') || (key === 'type') || (j2sReservedIdp(key))) return loop(new J2SAccess({'loc': tokenLoc(ignore),'obj': expr,'field': new J2SString({'loc': tokenLoc(field),'val': fieldStr})})); else if (key === 'SHARPID') return loop(new J2SAccess({'loc': tokenLoc(ignore),'obj': expr,'field': new J2SString({'private': true,'loc': tokenLoc(field),'val': fieldStr})})); else return parseTokenError("Wrong property name (access)", field); } break; case 'LPAREN': if (callAllowedp) { let loc = tokenLoc(peekToken()), args = $$arguments(); return loop(new J2SCall({'loc': loc,'fun': expr,'protocol': argsProtocol(args),'thisargs': ((expr instanceof J2SHopRef) ? (null) : (list(new J2SUndefined({'type': 'undefined','loc': loc})))),'args': args})); } else return expr; break; case 'TSTRING':case 'TEMPLATE':return new J2SCall({'loc': loc,'fun': expr,'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': tagCallArguments(loc)});break; case '?.': { let token = consumeAny$(), loc = tokenLoc(token), t = peekTokenType(); if ((['ID', 'RESERVED', 'type']?.includes(t)) || (j2sReservedIdp(t))) tokenPushBack$(makeToken('DOT', ".", loc));return loop(new J2SUnary({'type': 'unknown','loc': loc,'op': '?.','expr': expr})); } break; default: return expr; } })(expr)); return loop$; });let $$arguments = (() => { pushOpenToken(consumeToken$('LPAREN'));if (peekTokenType() === 'RPAREN') { popOpenToken(consumeAny$());return null; }
 else { const loop$ = ((function loop(revArgs) { switch (peekTokenType()) { case 'RPAREN': popOpenToken(consumeAny$());return reverse$(revArgs); break; case 'COMMA': { let tok = consumeAny$(); { let arg = ((peekTokenType() === 'RPAREN') ? (new J2SUndefined({'loc': tokenLoc(tok)})) : (assigExpr(false, false, true))); return loop(cons(arg, revArgs)); } } break; case 'EOF': return parseEofError(peekToken()); break; default: return parseTokenError("Illegal argument expression", peekToken()); } })(list(assigExpr(false, false, true)))); return loop$; } }
);let xmlExpression = ((tag, delim) => { return htmlParser(inputPort, configAdd(conf, {"tilde-level": tildeLevel}), mainParser, plugins, tag, delim); }
);let doctypeExpression = (() => { return htmlParser(inputPort, configAdd(conf, {"tilde-level": tildeLevel}), mainParser, plugins); }
);let tilde = ((token) => { return withTilde((() => { const loop$ = ((function loop(revStats) { switch (peekTokenType()) { case 'RBRACE': popOpenToken(consumeAny$());return new J2SSeq({'loc': tokenLoc(token),'nodes': reverse$(revStats)}); break; case 'CTAG': if (tokenValue(peekToken()) === '<script>') if (configGet(conf, {"parser": false}) === 'script-expression') return new J2SSeq({'loc': tokenLoc(token),'nodes': reverse$(revStats)}); else return loop(cons(statement(), revStats)); else return loop(cons(statement(), revStats)); break; case 'class': return loop(cons(classDeclaration(), revStats)); break; case 'RESERVED': { let stmt = (() => { switch (peekTokenValue()) { case 'import': return $$import(consumeAny$()); break; case 'export': return $$export(consumeAny$()); break; default: return statement(); } })(); return loop(cons(stmt, revStats)); } break; case 'ID':case 'type':{ let token = peekToken(); { let p = (plugins) && (assq(tokenValue(token), plugins)); if (p) { let stmt = cdr(p)(consumeAny$(), true, conf, parserController); return loop(cons(stmt, revStats)); } else return loop(cons(statement(), revStats)); } }break; default: return loop(cons(statement(), revStats)); } })(null)); return loop$; })); }
);let tildeExpression = (() => { let token = pushOpenToken(consumeAny$()); return new J2STilde({'loc': tokenLoc(token),'stmt': tilde(token)}); });let dollarExpression = (() => { pushOpenToken(consumeAny$());{ let expr = expression(false, false); popOpenToken(consumeToken$('RBRACE'));return expr; } }
);let templateExpressions = ((cellp) => { let blocktoexpresion = ((stmt) => { if (stmt instanceof J2SBlock) { let obj1066 = stmt; if ((pairp(obj1066.nodes)) && (nullp(cdr(obj1066.nodes)))) if (car(obj1066.nodes) instanceof J2SStmtExpr) { let obj1067 = car(obj1066.nodes); return obj1067.expr; } } }
);{ const loop$ = ((function loop(tok, vals) { { let val = new J2SString({'loc': tokenLoc(tok),'val': tokenValue(tok)}); switch (tokenType(tok)) { case 'TSTRING': return reverse$(cons(val, vals)); break; case 'TEMPLATE': { let stmt = statement(), expr = blocktoexpresion(stmt); if (expr) return loop(read_rp(j2sTemplateLexer(), inputPort), cons_(((cellp) ? (makeCell(expr)) : (expr)), val, vals)); else return parseNodeError("Expression expected", stmt); } break; default: return parseTokenError("Invalid template string ("+tokenType(tok)+")", tok); } } })(consumeAny$(), null)); return loop$; } }
);let templateExpression = (() => { return new J2STemplate({'loc': tokenLoc(peekToken()),'exprs': templateExpressions(false)}); }
);let number = ((val, conf) => { if (flonump(val)) return val; else if (bignump(val)) return val; else if (((val > confMaxInt(conf))) || ((val < confMinInt(conf)))) return val; else return val; }
);let idSansAsync = ((token) => { if (peekTokenType() === '=>') return arrowFunction('unknown', list(token), tokenLoc(token)); else if (tokenValue(token) === 'import') switch (peekTokenType()) { case 'LPAREN': consumeAny$();{ let path = expression(false, false); consumeToken$('RPAREN');return new J2SImportDynamic({'loc': tokenLoc(token),'path': path}); } break; case 'DOT': consumeAny$();{ let loc = tokenLoc(token), id = consumeToken$('ID'); if (tokenValue(id) === 'meta') return accessOrCall(new J2SHopRef({'loc': loc,'id': '%import-meta','type': 'any','module': false}), loc, true); else return parseTokenError("Illegal import", id); } break; default: return parseTokenError("Illegal import", consumeAny$()); } else return new J2SUnresolvedRef({'loc': tokenLoc(token),'id': tokenValue(token)}); }
);let primaryAsync = ((token) => { switch (peekTokenType()) { case 'function': return asyncExpression(token); break; case '=>': return asyncExpression(token); break; case 'ID':case 'type':{ let id = consumeAny$(); if (peekTokenType() === '=>') { tokenPushBack$(id);return asyncExpression(token); }
 else return idSansAsync(token); }break; case 'LPAREN': { let loc = tokenLoc(token), lpar = consumeAny$(); if (peekTokenType() === 'RPAREN') { let rpar = consumeAny$(); if (peekTokenType() === '=>') { tokenPushBack$(rpar);tokenPushBack$(lpar);return asyncExpression(token); }
 else { let fun = new J2SUnresolvedRef({'loc': loc,'id': 'async'}); return new J2SCall({'loc': loc,'fun': fun,'protocol': argsProtocol(null),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': null}); } } else { tokenPushBack$(lpar);{ let p = primary(false, false); if (p instanceof J2SArrow) return asynctogenerator(p); else if (p instanceof J2SParen) { let loc = tokenLoc(token), fun = new J2SUnresolvedRef({'loc': loc,'id': 'async'}); { let obj1068 = p; if (obj1068.expr instanceof J2SSequence) { let obj1069 = obj1068.expr; return new J2SCall({'loc': loc,'fun': fun,'protocol': argsProtocol(obj1069.exprs),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': obj1069.exprs}); } else return new J2SCall({'loc': loc,'fun': fun,'protocol': argsProtocol(list(obj1068.expr)),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': list(obj1068.expr)}); } } else return parseTokenError("wrong async expression", token); } }
 } break; default: return idSansAsync(token); } }
);let primary = ((destructuringp, spreadp) => { switch (peekTokenType()) { case 'PRAGMA': return jspragma(); break; case 'function': return functionExpression(); break; case 'class': return classExpression(); break; case 'this': return new J2SUnresolvedRef({'loc': tokenLoc(consumeAny$()),'id': 'this'}); break; case 'super': { let tok = consumeAny$(), loc = tokenLoc(tok); if (!(['DOT', 'LPAREN', 'LBRACKET']?.includes(peekTokenType()))) parseTokenError("'super' keyword unexpected here", tok);return new J2SUnresolvedRef({'loc': loc,'id': 'super'}); } break; case 'ID':case 'RESERVED':case 'type':{ let token = consumeAny$(); { let p = (plugins) && (assq(tokenValue(token), plugins)); if (p) return cdr(p)(token, false, conf, parserController); else if ((tokenValue(token) === 'service') && (['LPAREN', 'ID', 'type']?.includes(peekTokenType()))) { tokenPushBack$(token);return serviceExpression(); }
 else if (tokenValue(token) === 'async') return primaryAsync(token); else return idSansAsync(token); } }break; case 'SHARPID': { let token = consumeAny$(); if (peekTokenType() === 'in') return new J2SString({'private': true,'loc': tokenLoc(token),'val': tokenValue(token)}); else return parseTokenError("unexpected token", token); } break; case 'HOP': { let token = consumeToken$('HOP'); return new J2SHopRef({'loc': tokenLoc(token),'id': tokenValue(token)}); } break; case 'LPAREN': { let token = pushOpenToken(consumeAny$()); if (peekTokenType() === 'RPAREN') { let tok = consumeAny$(); popOpenToken(tok);if (peekTokenType() === '=>') return arrowFunction('unknown', null, tokenLoc(token)); else return parseTokenError("Unexpected token", tok); } else { let expr = expression(false, true); if (peekTokenType() === ':') return arrowTypescriptFunction(token, expr); else { popOpenToken(consumeToken$('RPAREN'));{ let rt = (((false) && (peekTokenType() === ':') && (typescript)) ? ((((tok) => { if (peekTokenType() === '=>') return typescriptType(); else { tokenPushBack$(tok);return 'unknown'; }
 })(consumeAny$()))) : ('unknown')); if (peekTokenType() === '=>') if (expr instanceof J2SAssig) return arrowFunction(rt, list(expr), tokenLoc(token)); else if (expr instanceof J2SUnresolvedRef) return arrowFunction(rt, list(expr), tokenLoc(token)); else if (expr instanceof J2SSequence) { let obj1070 = expr; return arrowFunction(rt, obj1070.exprs, tokenLoc(token)); } else if ((expr instanceof J2SObjInit) || (expr instanceof J2SArray) || (expr instanceof J2SBindExit)) return arrowFunction(rt, list(expr), tokenLoc(token)); else if (expr instanceof J2SDecl) return arrowFunction(rt, list(expr), tokenLoc(token)); else return parseNodeError("bad arrow parameter", expr); else return new J2SParen({'loc': tokenLoc(token),'expr': expr}); } }
 } } break; case 'LBRACKET': return arrayLiteral(destructuringp, true, 'array'); break; case 'SHARP': if (currentMode === 'hopscript') { consumeAny$();if (peekTokenType() === 'LBRACKET') return arrayLiteral(destructuringp, true, 'jsvector'); else return parseTokenError("Unexpected token", peekToken()); }
 else return parseTokenError("Unexpected token", peekToken()); break; case 'LBRACE': return objectLiteral(true); break; case 'NaN': { let token = consumeAny$(); return new J2SNumber({'loc': tokenLoc(token),'val': NaN}); } break; case 'Infinity': { let token = consumeAny$(); return new J2SNumber({'loc': tokenLoc(token),'val': +Infinity}); } break; case 'null': { let token = consumeAny$(); return new J2SNull({'loc': tokenLoc(token)}); } break; case 'undefined': { let token = consumeToken$('undefined'); return new J2SUndefined({'loc': tokenLoc(token)}); } break; case 'true':case 'false':{ let token = consumeAny$(); return new J2SBool({'loc': tokenLoc(token),'val': tokenType(token) === 'true'}); }break; case 'NUMBER': { let token = consumeToken$('NUMBER'); return new J2SNumber({'loc': tokenLoc(token),'val': number(tokenValue(token), conf)}); } break; case 'OCTALNUMBER': { let token = consumeToken$('OCTALNUMBER'); return new J2SOctalNumber({'loc': tokenLoc(token),'val': number(tokenValue(token), conf)}); } break; case 'BIGINT': { let token = consumeToken$('BIGINT'); return new J2SNumber({'loc': tokenLoc(token),'val': number(tokenValue(token), conf)}); } break; case 'STRING':case 'TSTRING':{ let token = consumeAny$(); return new J2SString({'escape': null,'loc': tokenLoc(token),'val': tokenValue(token)}); }break; case 'ESTRING': { let token = consumeToken$('ESTRING'); return new J2SString({'escape': ['escape'],'loc': tokenLoc(token),'val': tokenValue(token)}); } break; case 'OSTRING': { let token = consumeToken$('OSTRING'); return new J2SString({'escape': ['escape', 'octal'],'loc': tokenLoc(token),'val': tokenValue(token)}); } break; case 'TEMPLATE': return templateExpression(); break; case 'EOF': return parseEofError(peekToken()); break; case '/':case '/=':{ let pattern = readRegexp(peekTokenType()); { let token = consumeAny$(); return new J2SRegExp({'loc': tokenLoc(token),'val': car(tokenValue(pattern)),'flags': cdr(tokenValue(pattern))}); } }break; case 'OTAG': return xmlExpression(consumeAny$(), false); break; case 'HTML': { let tag = consumeAny$(), loc = tokenLoc(tag); return new J2SCall({'loc': loc,'fun': j2sTagtoexpr(tag, true),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': list(new J2SUndefined({'loc': loc}))}); } break; case 'HTMLCOMMENT': { let tag = consumeAny$(), loc = tokenLoc(tag); return new J2SCall({'loc': tokenLoc(tag),'fun': j2sTagtoexpr(makeToken(tag, '<!-->', loc), true),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': loc})),'args': list(new J2SNativeString({'loc': loc,'val': tokenValue(tag)}))}); } break; case 'OHTML': return xmlExpression(consumeAny$(), true); break; case 'DOCTYPE': consumeAny$();return doctypeExpression(); break; case 'TILDE': { let token = pushOpenToken(consumeAny$()); return new J2STilde({'loc': tokenLoc(token),'stmt': tilde(token)}); } break; case 'DOLLAR': if ((tildeLevel > 0)) return withDollar((() => { { let ignore = pushOpenToken(consumeAny$()), expr = expression(false, false); popOpenToken(consumeToken$('RBRACE'));return new J2SDollar({'loc': tokenLoc(ignore),'node': expr}); } }
)); else return parseTokenError("Invalid ${ ... } statement", consumeAny$()); break; case 'DOTS': { let p = (plugins) && (assq(peekTokenValue(), plugins)); if (p) return cdr(p)(consumeAny$(), true, conf, parserController); else if (spreadp) return new J2SSpread({'stype': 'array','loc': tokenLoc(consumeAny$()),'expr': assigExpr(false, false, false)}); else if (destructuringp) { consumeAny$();{ let param = consumeRestParam$(); if (peekTokenType() === 'RPAREN') return param; else return parseTokenError("expecting ')'", consumeAny$()); } }
 else return parseTokenError("Unexpected token", consumeAny$()); } break; default: { let p = (plugins) && (assq(peekTokenValue(), plugins)); if (p) return cdr(p)(consumeAny$(), true, conf, parserController); else return parseTokenError("unexpected token", peekToken()); } } }
);let jspragma = (() => { { let token = consumeToken$('PRAGMA'), LPAREN = pushOpenToken(consumeToken$('LPAREN')), str = consumeAny$(), RPAREN = consumeToken$('RPAREN'); popOpenToken(RPAREN);if (['STRING', 'ESTRING', 'OSTRING']?.includes(car(str))) return callWithInputString(tokenValue(str), ((ip) => { return new J2SPragma({'loc': tokenLoc(token),'expr': read(ip)}); }
)); else return parseTokenError("Unexpected token", str); } }
);let arrayLiteral = ((destructuringp, spreadp, type) => { let token = pushOpenToken(consumeToken$('LBRACKET')); let parseArrayElement = ((arrayEl, revEls, length) => { switch (peekTokenType()) { case 'COMMA': consumeAny$();return parseArray(cons(arrayEl, revEls), (length + 1)); break; case 'RBRACKET': consume$('RBRACKET');return new J2SArray({'loc': tokenLoc(token),'exprs': reverse$(cons(arrayEl, revEls)),'len': (length + 1),'type': type}); break; default: return parseTokenError("Unexpected token", consumeAny$()); } }
);let parseArray = ((revEls, length) => { switch (peekTokenType()) { case 'RBRACKET': popOpenToken(consumeAny$());return new J2SArray({'loc': tokenLoc(token),'type': type,'exprs': reverse$(revEls),'len': length}); break; case 'COMMA': { let token = consumeAny$(); return parseArray(cons(new J2SArrayAbsent({'loc': tokenLoc(token)}), revEls), (length + 1)); } break; case 'DOTS': { let token = consumeAny$(); if ((destructuringp) || (spreadp)) { let arrayEl = assigExpr(false, false, true), spread = new J2SSpread({'stype': 'array','loc': tokenLoc(token),'expr': arrayEl}); return parseArrayElement(spread, revEls, length); } else return parseTokenError("Unexpected token", consumeAny$()); } break; default: { let arrayEl = assigExpr(false, false, false); return parseArrayElement(arrayEl, revEls, length); } } }
);return parseArray(null, 0); });let propertyName = ((destructuringp, inclassp) => { switch (peekTokenType()) { case 'SHARPID': if (inclassp) { let token = consumeAny$(); return new J2SString({'loc': tokenLoc(token),'private': true,'val': symboltostring(tokenValue(token))}); } else return parseTokenError("Private field must be declared in an enclosing class", consumeAny$()); break; case 'ID':case 'RESERVED':case 'type':{ let token = consumeAny$(); switch (tokenValue(token)) { case 'get':case 'set':return token;break; default: return new J2SString({'loc': tokenLoc(token),'val': symboltostring(tokenValue(token))}); } }break; case 'STRING': { let token = consumeToken$('STRING'); return new J2SString({'escape': null,'loc': tokenLoc(token),'val': tokenValue(token)}); } break; case 'ESTRING': { let token = consumeToken$('ESTRING'); return new J2SString({'escape': ['escape'],'loc': tokenLoc(token),'val': tokenValue(token)}); } break; case 'OSTRING': { let token = consumeToken$('OSTRING'); return new J2SString({'escape': ['escape', 'octal'],'loc': tokenLoc(token),'val': tokenValue(token)}); } break; case 'NUMBER': { let token = consumeToken$('NUMBER'); return new J2SNumber({'loc': tokenLoc(token),'val': number(tokenValue(token), conf)}); } break; case 'OCTALNUMBER': { let token = consumeToken$('OCTALNUMBER'); return new J2SOctalNumber({'loc': tokenLoc(token),'val': number(tokenValue(token), conf)}); } break; case 'true':case 'false':case 'null':{ let token = consumeAny$(); return new J2SString({'loc': tokenLoc(token),'val': symboltostring(tokenValue(token))}); }break; case 'LBRACKET': { let token = pushOpenToken(consumeToken$('LBRACKET')), expr = expression(false, false); popOpenToken(consumeToken$('RBRACKET'));return expr; } break; case 'DOTS': if (destructuringp) return consumeAny$(); else return parseTokenError("Unexpected token in property name name", peekToken()); break; default: if (j2sReservedIdp(peekTokenType())) { let token = consumeAny$(); switch (tokenValue(token)) { case 'get':case 'set':return token;break; default: return new J2SString({'loc': tokenLoc(token),'val': symboltostring(tokenValue(token))}); } } else return parseTokenError("Wrong property name", peekToken()); } }
);let objectLiteral = ((destructuringp) => { let findProp = ((name, props) => { return find(((prop) => { if (prop instanceof J2SAccessorPropertyInit) { let obj1071 = prop; { let obj1072 = obj1071.name; return obj1072.val === name; } } }
), props); }
);let propertyAccessor = ((id, tokname, name, props) => { { let [params, args] = functionParams(false); { let ty = optType(), body = funBody(params, args, currentMode), mode = (javascriptMode(body)) || (currentMode), loc = tokenLoc(tokname), fun = new J2SFun({'mode': mode,'loc': loc,'src': funSrc,'thisp': newDeclThis(loc),'params': params,'name': loctofunname("get", loc),'vararg': restParams(params),'rutype': ty,'body': body}), oprop = findProp(symboltostring$(tokenValue(id)), props), prop = (oprop) || (new J2SAccessorPropertyInit({'loc': tokenLoc(tokname),'get': new J2SUndefined({'loc': tokenLoc(id)}),'set': new J2SUndefined({'loc': tokenLoc(id)}),'name': new J2SString({'loc': tokenLoc(id),'val': symboltostring(tokenValue(id))})})); { let obj1073 = prop; if (name === 'get') if (obj1073.get instanceof J2SUndefined) obj1073.get = fun; else parseTokenError("Wrong property", peekToken()); else if (obj1073.set instanceof J2SUndefined) obj1073.set = fun; else parseTokenError("Wrong property", peekToken());if (!oprop) return prop; } } } }
);let dynamicPropertyAccessor = ((loc, propname, name, props) => { { let [params, args] = functionParams(false); { let ty = optType(), body = funBody(params, args, currentMode), mode = (javascriptMode(body)) || (currentMode), fun = new J2SFun({'name': loctofunname("dyn", loc),'src': funSrc,'mode': mode,'loc': loc,'thisp': newDeclThis(loc),'params': params,'vararg': restParams(params),'rutype': ty,'body': body}), prop = new J2SAccessorPropertyInit({'loc': loc,'get': new J2SUndefined({'loc': loc}),'set': new J2SUndefined({'loc': loc}),'name': propname}); { let obj1074 = prop; if (name === 'get') if (obj1074.get instanceof J2SUndefined) obj1074.get = fun; else parseTokenError("Wrong property", peekToken()); else if (obj1074.set instanceof J2SUndefined) obj1074.set = fun; else parseTokenError("Wrong property", peekToken());return prop; } } } }
);let propertyInit = ((props) => { let token = peekToken(); { const loop$ = ((function loop(tokname) { { let name = ((pairp(tokname)) ? (tokenValue(tokname)) : undefined); if (['get', 'set']?.includes(name)) switch (peekTokenType()) { case 'ID':case 'RESERVED':case 'type':case 'get':case 'set':return propertyAccessor(consumeAny$(), tokname, name, props);break; case 'STRING':case 'ESTRING':case 'OSTRING':{ let tok = consumeAny$(), id = makeToken('ID', stringtosymbol(tokenValue(tok)), tokenLoc(tok)); return propertyAccessor(id, tokname, name, props); }break; case ':': { let ignore = consumeAny$(), loc = tokenLoc(ignore), val = assigExpr(false, false, false); return new J2SDataPropertyInit({'loc': loc,'name': new J2SString({'loc': loc,'val': symboltostring(name)}),'val': val}); } break; case 'COMMA':case 'RBRACE':return loop(new J2SString({'loc': tokenLoc(token),'val': symboltostring(tokenValue(token))}));break; case 'LBRACKET': consumeAny$();{ let expr = expression(false, false); consumeToken$('RBRACKET');return dynamicPropertyAccessor(tokenLoc(token), expr, name, props); } break; case 'LPAREN': return new J2SDataPropertyInit({'loc': tokenLoc(token),'name': new J2SString({'loc': tokenLoc(token),'val': symboltostring(tokenValue(token))}),'val': $$function(false, token, '__proto__')}); break; default: if (j2sReservedIdp(peekTokenType())) return propertyAccessor(consumeAny$(), tokname, name, props); else return parseTokenError("Wrong property name (init)", peekToken()); } else if ((tokenValue(token) === 'async') && (peekTokenType() === 'ID')) { let token = consumeAny$(), loc = tokenLoc(token), val = (() => { switch (peekTokenType()) { case 'LPAREN': { let fun = $$function(false, token, '__proto__'); if (fun instanceof J2SFun) return asynctogenerator(fun); else return parseTokenError("Illegal async function expression", token); } break; default: return parseTokenError("Unexpected token", peekToken()); } })(), name = new J2SString({'loc': tokenLoc(token),'val': symboltostring(tokenValue(token))}); return new J2SDataPropertyInit({'loc': loc,'name': name,'val': val}); } else if ((pairp(tokname)) && (tokenType(tokname) === 'DOTS')) return new J2SDataPropertyInit({'loc': tokenLoc(tokname),'name': new J2SUndefined({'loc': tokenLoc(tokname)}),'val': new J2SSpread({'loc': tokenLoc(tokname),'stype': 'object','expr': assigExpr(false, false, false)})}); else { let loc = tokenLoc(token), val = (() => { switch (peekTokenType()) { case 'COMMA':case 'RBRACE':if (['ID', 'type']?.includes(tokenType(token))) return new J2SUnresolvedRef({'loc': loc,'id': tokenValue(token)}); else return parseTokenError("Unexpected token", token);break; case 'LPAREN': return $$function(false, token, '__proto__'); break; case ':': consumeAny$();return assigExpr(false, false, false); break; case '=': if (destructuringp) { consumeAny$();return destructureOr(loc, new J2SUnresolvedRef({'loc': loc,'id': tokenValue(token)}), assigExpr(false, false, false)); }
 else return parseTokenError("Unexpected \"=\"", peekToken()); break; default: return parseTokenError("Unexpected token", peekToken()); } })(); return new J2SDataPropertyInit({'loc': loc,'name': tokname,'val': val}); } } })(propertyName(destructuringp, false))); return loop$; } });pushOpenToken(consumeToken$('LBRACE'));if (peekTokenType() === 'RBRACE') { let token = consumeAny$(); popOpenToken(token);return new J2SObjInit({'loc': tokenLoc(token),'inits': null}); } else { const loop$ = ((function loop(revProps) { if (peekTokenType() === 'RBRACE') { let token = consumeAny$(); popOpenToken(token);return new J2SObjInit({'loc': tokenLoc(token),'inits': reverse$(revProps)}); } else { consume$('COMMA');if (peekTokenType() === 'RBRACE') return loop(revProps); else { let newp = propertyInit(revProps); return loop(((newp) ? (cons(newp, revProps)) : (revProps))); } }
 })(list(propertyInit(null)))); return loop$; } }
);let abspath = (() => { let path = inputPortName(inputPort); if (absoluteFileNamep(path)) return path; else return fileNameCanonicalize$(makeFileName(pwd(), path)); });let nodesMode = ((nodes) => { let mode = ((pairp(nodes)) ? (javascriptModeNodes(nodes)) : undefined); if (symbolp(mode)) return mode; else if (esModule) return 'strict'; else return 'normal'; });let program = ((dp) => { tildeLevel = ((dp) ? (1) : (0));{ let obj1075 = sourceElements(); { let module = javascriptModuleNodes(obj1075.nodes), mode = nodesMode(obj1075.nodes); return assignImportProgram$(new J2SProgram({'loc': obj1075.loc,'endloc': obj1075.endloc,'module': module,'sourceMap': configGet(conf, {"source-mapping-url": sourceMap}),'path': configGet(conf, {"filename": abspath()}),'main': configGet(conf, {"module-main": false}),'name': configGet(conf, {"module-name": false}),'mode': mode,'types': append(types, interfaces),'exports': reverse(exports),'nodes': map$(((n) => { return dialect(n, mode, conf); }
), obj1075.nodes)}), conf); } } }
);let $$eval = ((mode) => { tildeLevel = 0;{ let obj1076 = sourceElements(); { let mode = (mode) || (nodesMode(obj1076.nodes)); return new J2SProgram({'loc': obj1076.loc,'endloc': obj1076.endloc,'path': configGet(conf, {"filename": abspath()}),'name': configGet(conf, {"module-name": false}),'mode': mode,'exports': reverse(exports),'nodes': map$(((n) => { return dialect(n, mode, conf); }
), obj1076.nodes)}); } } }
);let evalStrict = (() => { currentMode = 'strict';return $$eval('strict'); }
);let repl = (() => { let el = replElement(); if (el instanceof J2SNode) { let obj1077 = el; return new J2SProgram({'loc': obj1077.loc,'endloc': obj1077.loc,'main': configGet(conf, {"module-main": false}),'name': configGet(conf, {"module-name": false}),'path': configGet(conf, {"filename": abspath()}),'exports': reverse(exports),'nodes': list(dialect(el, 'normal', conf))}); } else return el; });let xml = (() => { let el = xmlExpression(consumeAny$(), true); if (el instanceof J2SNode) { let obj1078 = el; return new J2SProgram({'loc': obj1078.loc,'endloc': obj1078.loc,'main': configGet(conf, {"module-main": false}),'name': configGet(conf, {"module-name": false}),'path': configGet(conf, {"filename": abspath()}),'exports': reverse(exports),'nodes': list(dialect(el, 'normal', conf))}); } else return el; });let withPlugins = ((fun) => { return ((ps) => { let old = plugins; plugins = ps;{ let v = fun(); plugins = old;return v; } }); }
);parserController = [primary, ((d, s, ps) => { let old = plugins; plugins = ps;{ let v = withTilde((() => { return primary(d, s); }
)); plugins = old;return v; } }), peekToken, consumeToken$, consumeAny$, ((i, d, ps) => { let old = plugins; plugins = ps;{ let v = expression(i, d); plugins = old;return v; } }), withPlugins(statement), withPlugins(block), ((i, d, s, ps) => { let old = plugins; plugins = ps;{ let v = condExpr(i, d, s); plugins = old;return v; } }), withPlugins((() => { return withTilde((() => { return condExpr(false, false, false); }
)); }
)), ((i, d, s, ps) => { let old = plugins; plugins = ps;{ let v = assigExpr(i, d, s); plugins = old;return v; } })];let mainParser = ((inputPort, conf) => { switch (configGet(conf, {"parser": false})) { case 'script-expression': return withTilde(tildeExpression); break; case 'tilde-expression': return withTilde(tildeExpression); break; case 'dollar-expression': return dollarExpression(); break; case 'module': return program(false); break; case 'repl': return repl(); break; case 'xml': return xml(); break; case 'eval': return $$eval(false); break; case 'eval-strict': return evalStrict(); break; case 'client-program': return program(true); break; default: return program(false); } }
);return mainParser(inputPort, conf); }
)
const j2sTagtoexpr = ((tag, forceCase) => { let s = symboltostring$(tokenValue(tag)); { const loop$ = ((function loop(type, fc) { { let i = stringIndexRight(type, '.'); if (i) { let s = type.substring((i + 1), type.length); return new J2SAccess({'loc': tokenLoc(tag),'obj': loop(type.substring(0, i), false),'field': new J2SString({'loc': tokenLoc(tag),'val': ((fc) ? (stringUpcase(s)) : (s))})}); } else return new J2SUnresolvedRef({'loc': tokenLoc(tag),'id': stringtosymbol(((fc) ? (stringUpcase(type)) : (type)))}); } })(s.substring(1, (s.length - 1)), forceCase)); return loop$; } })
const javascriptModeNodes = ((nnodes) => { let octalError = ((s) => { { let obj1079 = s; throw new $ioParseError({'proc': "js-symbol",'msg': "Octal literals are not allowed in strict mode",'obj': obj1079.val,'fname': locFilename(obj1079.loc),'location': locOffset(obj1079.loc)}); } }
);let checkOctalString = ((n) => { if (n instanceof J2SStmtExpr) { let obj1080 = n; return checkOctalString(obj1080.expr); } else if (n instanceof J2SString) { let obj1081 = n; if (obj1081.escape?.includes('octal')) return octalError(n); } else return false; }
);let stricterMode = ((mode, m) => { if (!mode) return m; else if (!m) return mode; else if (mode === 'hopscript') return mode; else if (m === 'hopscript') return m; else if (mode === 'strict') return mode; else if (m === 'strict') return m; else return m; }
);{ const loop$ = ((function loop(nodes, mode) { if (pairp(nodes)) { let m = javascriptMode(car(nodes)); if (symbolp(m)) { if (['strict', 'hopscript', 'typescript']?.includes(m)) forEach(checkOctalString, nnodes);return loop(cdr(nodes), stricterMode(mode, m)); }
 else if (m) return loop(cdr(nodes), mode); else if (car(nodes) instanceof J2SStmtExpr) { let obj1082 = car(nodes); if (obj1082.expr instanceof J2SString) return loop(cdr(nodes), mode); else return mode; } else return mode; } else return mode; })(nnodes, false)); return loop$; } }
)
const parseNodeError = ((msg, node) => { { let obj1083 = node; { const mc1084 = obj1083.loc; if (mc1084 instanceof Location) { const fname = mc1084.filename, loc = mc1084.offset;; throw new $ioParseError({'proc': "hopscript",'msg': msg,'obj': j2stosexp(node),'fname': fname,'location': obj1083.loc}); } else throw new $ioParseError({'proc': "hopscript",'msg': msg,'obj': j2stosexp(node)}); } } }
)
const destructureFunParams = ((params, args, body) => { if (find(((a) => { return a instanceof J2SObjInit; }
), args)) { let obj1085 = body; { let decls = appendMap(((p, a) => { if (!a) return null; else if (a instanceof J2SUnresolvedRef) return null; else return j2sDestructure(a, p, true); }
), params, args), vdecls = new J2SVarDecls({'loc': obj1085.loc,'decls': decls}); checkUnique(append(params, decls), parseNodeError);obj1085.nodes = cons(vdecls, obj1085.nodes);return body; } } else return body; }
)
const j2sDestructure = ((lhs, decl, bind) => { { let obj1086 = lhs; return destructurePath(lhs, decl, '*', bind); } }
)
const destructureOr = ((loc, axs, def) => { return new J2SBinary({'type': 'unknown','loc': loc,'op': 'OR*','lhs': axs,'rhs': def}); }
)
const destructurePath = ((lhs, decl, path, bind) => { let J2SDeclAssig = ((loc, id, val) => { if (bind) return new J2SDeclInit({'loc': loc,'id': id,'binder': 'let','val': val}); else return new J2SAssig({'loc': loc,'lhs': new J2SUnresolvedRef({'loc': loc,'id': id}),'rhs': val}); }
);let destructureUnref = ((lhs, src, path) => { { let obj1087 = lhs; return list(J2SDeclAssig(obj1087.loc, obj1087.id, new J2SDConsumer({'loc': obj1087.loc,'decl': decl,'expr': src,'path': path}))); } }
);let destructureAccess = ((lhs, src, path) => { if (!bind) { let obj1088 = lhs; return list(new J2SAssig({'loc': obj1088.loc,'lhs': lhs,'rhs': src})); } else return parseNodeError("Bad access declaration", lhs); }
);let initName = (($$this) => { if ($$this instanceof J2SDataPropertyInit) { let obj1089 = $$this; if (obj1089.name instanceof J2SString) { let obj1090 = obj1089.name; return obj1090.val; } } }
);let destructureObj = ((lhs, tmp, path) => { { let obj1091 = lhs; return appendMap(((init) => { if (init instanceof J2SDataPropertyInit) { let obj1092 = init; if (obj1092.val instanceof J2SUnresolvedRef) return destructure(obj1092.val, new J2SAccess({'loc': obj1092.loc,'obj': tmp,'field': obj1092.name}), undefined, bind); else if (obj1092.val instanceof J2SBinary) { let obj1093 = obj1092.val; obj1093.lhs = new J2SAccess({'loc': obj1092.loc,'obj': tmp,'field': obj1092.name});{ let obj1094 = obj1092.name; return destructure(new J2SUnresolvedRef({'loc': obj1092.loc,'id': stringtosymbol(obj1094.val)}), obj1092.val, undefined, bind); } } else if (obj1092.val instanceof J2SAssig) { let obj1095 = obj1092.val; return destructure(obj1095.lhs, destructureOr(obj1092.loc, new J2SAccess({'loc': obj1092.loc,'obj': tmp,'field': obj1092.name}), obj1095.rhs), undefined, bind); } else if (obj1092.val instanceof J2SSpread) { let obj1096 = obj1092.val; { let decl = new J2SDeclInit({'binder': 'let','loc': obj1096.loc,'id': gensym('%dots'),'val': new J2SDConsumer({'loc': obj1096.loc,'decl': decl,'expr': new J2SCall({'loc': obj1096.loc,'fun': new J2SHopRef({'loc': obj1096.loc,'id': 'js-jsobject-spread','type': 'any','module': false}),'thisargs': null,'args': list(tmp, new J2SPragma({'loc': obj1096.loc,'expr': undefined}), new J2SHopRef({'loc': obj1096.loc,'id': '%this','type': 'any','module': false}))}),'path': path})}); return cons(decl, destructure(obj1096.expr, new J2SRef({'loc': obj1096.loc,'type': 'unknown','decl': decl}), undefined, bind)); } } else return destructure(obj1092.val, new J2SAccess({'loc': obj1092.loc,'obj': tmp,'field': obj1092.name}), undefined, bind); } else return parseNodeError("Bad object argument", init); }
), obj1091.inits); } }
);let destructureArray = ((lhs, tmp, path) => { let destructureAref = ((e, i, tmp, path) => { if (e instanceof J2SArrayAbsent) return null; else if (e instanceof J2SSpread) { let obj1097 = e; { let decl = new J2SDeclInit({'binder': 'let','loc': obj1097.loc,'id': gensym('%dots'),'val': new J2SDConsumer({'loc': obj1097.loc,'decl': decl,'expr': new J2SCall({'loc': obj1097.loc,'fun': new J2SAccess({'loc': obj1097.loc,'obj': tmp,'field': new J2SString({'loc': obj1097.loc,'val': "slice"})}),'thisargs': list(new J2SUndefined({'type': 'undefined','loc': obj1097.loc})),'args': list(new J2SNumber({'loc': obj1097.loc,'val': i}))}),'path': path})}); return cons(decl, destructure(obj1097.expr, new J2SRef({'loc': obj1097.loc,'type': 'unknown','decl': decl}), undefined, bind)); } } else if (e instanceof J2SAssig) { let obj1098 = e; return destructure(obj1098.lhs, destructureOr(obj1098.loc, new J2SAccess({'loc': obj1098.loc,'obj': tmp,'field': new J2SNumber({'loc': obj1098.loc,'val': i})}), obj1098.rhs), undefined, bind); } else { let obj1099 = e; return destructure(e, new J2SAccess({'loc': obj1099.loc,'obj': tmp,'field': new J2SNumber({'loc': obj1099.loc,'val': i})}), undefined, bind); } }
);{ let obj1100 = lhs; return appendMap(((e, i) => { return destructureAref(e, i, tmp, path); }
), obj1100.exprs, iota(obj1100.len)); } }
);let destructureTmp = ((lhs, src, path, destructure_tmp) => { if (src instanceof J2SUnresolvedRef) return destructure_tmp(lhs, src, path); else { let obj1101 = lhs; { let decl = new J2SDeclInit({'binder': 'let','loc': obj1101.loc,'id': gensym('%tmp'),'val': src}); return cons(decl, destructure_tmp(lhs, new J2SRef({'loc': obj1101.loc,'type': 'unknown','decl': decl}), path)); } } }
);let destructure = ((lhs, src, path, bind) => { if (lhs instanceof J2SUnresolvedRef) return destructureUnref(lhs, src, path); else if (lhs instanceof J2SObjInit) return destructureTmp(lhs, src, path, destructureObj); else if (lhs instanceof J2SArray) return destructureTmp(lhs, src, path, destructureArray); else if (lhs instanceof J2SAccess) return destructureAccess(lhs, src, path); else return parseNodeError("Bad declaration", lhs); }
);{ let obj1102 = decl; return destructure(lhs, new J2SRef({'loc': obj1102.loc,'type': 'unknown','decl': decl}), path, bind); } }
)
const javascriptMode = (node) => { return node.javascriptMode(node); }
J2SNode.prototype.javascriptMode = ((node) => { return false; })
J2SSeq.prototype.javascriptMode = ((node) => { { let obj1103 = node; return javascriptModeNodes(obj1103.nodes); } })
J2SStmtExpr.prototype.javascriptMode = ((node) => { { let obj1104 = node; if (obj1104.expr instanceof J2SString) { let obj1105 = obj1104.expr; if (pairp(obj1105.escape)) return obj1105.escape?.includes('octal'); else if ("use strict" === obj1105.val) return 'strict'; else if ("use hopscript" === obj1105.val) return 'hopscript'; else return false; } } })
const javascriptLanguage = (node) => { return node.javascriptLanguage(node); }
J2SNode.prototype.javascriptLanguage = ((node) => { return false; })
J2SSeq.prototype.javascriptLanguage = ((node) => { { let obj1106 = node; if (pairp(obj1106.nodes)) return javascriptLanguage(car(obj1106.nodes)); } })
J2SStmtExpr.prototype.javascriptLanguage = ((node) => { { let obj1107 = node; if (obj1107.expr instanceof J2SString) { let obj1108 = obj1107.expr; if (obj1108.val === "use strict") return false; else if (obj1108.val === "use hopscript") return false; else if (obj1108.val.startsWith("use ")) return obj1108.val.substring(4); } } })
const javascriptModuleNodes = ((nnodes) => { const loop$ = ((function loop(nodes) { if (pairp(nodes)) return (javascriptModule(car(nodes))) || (loop(cdr(nodes))); })(nnodes)); return loop$; })
const javascriptModule = (node) => { return node.javascriptModule(node); }
J2SNode.prototype.javascriptModule = ((node) => { return false; })
J2SSeq.prototype.javascriptModule = ((node) => { { let obj1109 = node; return javascriptModuleNodes(obj1109.nodes); } })
J2SStmtExpr.prototype.javascriptModule = ((node) => { { let obj1110 = node; if (obj1110.expr instanceof J2SString) { let obj1111 = obj1110.expr; if (obj1111.val.startsWith("(module ")) return callWithInputString(obj1111.val, read); } } })
const dialect = ((node, mode, conf) => { if (!(configGet(conf, {"no-dialect": false}))) { hopscriptModeFun$(node, mode);hopscriptCnstFun$(node, mode);hopscriptLet$(node, mode);if (configGet(conf, {"target-language": false}) !== 'javascript') hopscriptAsyncImport$(node, mode);if (!(['strict', 'hopscript', 'ecmascript6', 'ecmascript2017']?.includes(mode))) { if (!(configGet(conf, {"es6-let": false}))) disableEs6Let(node);if (!(configGet(conf, {"es6-default-value": false}))) disableEs6DefaultValue(node);if (!(configGet(conf, {"es6-arrow-function": false}))) disableEs6Arrow(node);if (!(configGet(conf, {"es6-rest-argument": false}))) disableEs6RestArgument(node); }
disableReservedIdent(node, mode); }
return node; }
)
const dupExpr = (e) => { return e.dupExpr(e); }
J2SExpr.prototype.dupExpr = ((e) => { return e; })
J2SUnresolvedRef.prototype.dupExpr = ((e) => { return e.duplicate({}); })
J2SAccess.prototype.dupExpr = ((e) => { { let obj1112 = e; return e.duplicate({'obj': dupExpr(obj1112.obj),'field': dupExpr(obj1112.field)}); } })
J2SParen.prototype.dupExpr = ((e) => { { let obj1113 = e; return e.duplicate({'expr': dupExpr(obj1113.expr)}); } })
const checkUnique = ((declList, parseError) => { const loop$ = ((function loop(l) { if (pairp(l)) { { let obj1114 = car(l); forEach(((d) => { { let obj1115 = d; if (obj1115.id === obj1114.id) return parseError("Duplicate parameter name not allowed in this context", d); } }
), cdr(l)); }return loop(cdr(l)); }
 })(declList)); return loop$; })
const argsProtocol = ((args) => { if (find(((x) => { return x instanceof J2SSpread; }
), args)) return 'spread'; else return 'direct'; }
)
const assignImportProgram$ = ((prgm, conf) => { let assign$ = ((tgt, src) => { vectorForEach(((f) => { if (classFieldMutator(f)) { let v = classFieldAccessor(f)(src); return classFieldMutator(f)(tgt, v); } }
), classAllFields(objectClass(src)));return tgt; }
);{ let tgt = configGet(conf, {"import-program": false}); if (tgt) return assign$(tgt, prgm); else return prgm; } }
)
