/*=====================================================================*/
/*    .../gallery/work/node_modules/@hop/hopc/lib/ts-loader.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Fri Nov 17 08:15:59 2023                          */
/*    Last change :  Mon Mar 11 07:47:12 2024 (serrano)                */
/*    Copyright   :  2023-24 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    hop loader/resolver loaders.                                     */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { readFile, writeFile, lstat, rename } from 'node:fs/promises';
import { features } from 'node:process';
import { existsSync, writeSync } from 'fs';
import { normalize, dirname, basename, extname, resolve as resolvePath } from 'node:path';
import { cwd } from 'node:process';
import { fileURLToPath, pathToFileURL, URL } from 'node:url';

const tsCompiler =
   (features.hop ? "./ts-hop-compiler.mjs" : "./ts-js-compiler.mjs");
let tsCompile = false;

/*---------------------------------------------------------------------*/
/*    debug ...                                                        */
/*---------------------------------------------------------------------*/
function debug(...args) {
/*    args.forEach(a => writeSync(2, a.toString()));                   */
/*    writeSync(2, "\n");                                              */
}

/*---------------------------------------------------------------------*/
/*    HipHop extension                                                 */
/*---------------------------------------------------------------------*/
const extensionsRegex = /\.ts$/;

/*---------------------------------------------------------------------*/
/*    resolve ...                                                      */
/*---------------------------------------------------------------------*/
export async function resolve(specifier, context, nextResolve) {
   debug("ts.resolve specifier=", specifier);
   if (extensionsRegex.test(specifier)) {
      const format = await getPackageType(specifier);
      const { url: nurl } = await nextResolve(specifier, { ...context, format });

      const transformedSource = await compile(new URL(nurl));

      return {
	 shortCircuit: true,
	 url: "file://" + transformedSource
      };
   }

   return nextResolve(specifier);
}

/*---------------------------------------------------------------------*/
/*    load ...                                                         */
/*---------------------------------------------------------------------*/
export async function load(url, context, nextLoad) {
   debug("ts.load url=", url);
   if (extensionsRegex.test(url)) {
      const nurl = await compile(new URL(url));
      const format = await getPackageType(nurl);

      debug("ts url=", url, " nurl=", nurl, " fmt=", format);
      return nextLoad("file://" + nurl, { ...context, format });
   } else {
      return nextLoad(url);
   }
}

/*---------------------------------------------------------------------*/
/*    getPackageType ...                                               */
/*---------------------------------------------------------------------*/
async function getPackageType(url) {
   if (/[.]mjs$/.test(url)) {
      return "module";
   }
   // `url` is only a file path during the first iteration when passed the
   // resolved url from the load() loader
   // an actual file path from load() will contain a file extension as it's
   // required by the spec
   // this simple truthy check for whether `url` contains a file extension will
   // work for most projects but does not cover some edge-cases (such as
   // extensionless files or a url ending in a trailing space)
   const isFilePath = !!extname(url);
   // If it is a file path, get the directory it's in
   const dir = isFilePath ?
      dirname(typeof url === "string" ? url : fileURLToPath(url)):
      url;
   // Compose a file path to a package.json in the same directory,
   // which may or may not exist
   const packagePath = resolvePath(dir, 'package.json');
   // Try to read the possibly nonexistent package.json
   const type = await readFile(packagePath, { encoding: 'utf8' })
      .then((filestring) => JSON.parse(filestring).type)
      .catch((err) => {
	 if (err?.code !== 'ENOENT') console.error(err);
      });
   // Ff package.json existed and contained a `type` field with a value, voila
   if (type) return type;
   // Otherwise, (if not at the root) continue checking the next directory up
   // If at the root, stop and return false
   return dir.length > 1 && getPackageType(resolvePath(dir, '..'));
} 

/*---------------------------------------------------------------------*/
/*    compile ...                                                      */
/*---------------------------------------------------------------------*/
export async function compile(url) {
   if (!tsCompile) {
      tsCompile = (await import(tsCompiler)).compile;
   }
   const path = fileURLToPath(url);
   const target = dirname(path)
      + "/._"
      + basename(path).replace(/^\._/, "").replace(/\.ts$/, ".mjs");

   if (await newer(target, path)) {
      return target;
   } else {
      const prog = await tsCompile(path);

      if (prog) {
	 if (prog !== path) {
	    await rename(prog, target);
	 }
	 return target;
      } else {
	 return path;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    newer ...                                                        */
/*---------------------------------------------------------------------*/
async function newer(target, source) {
   if (!existsSync(target)) {
      return false;
   } else {
      const tstat = await lstat(target);
      const sstat = await lstat(source);

      return (tstat.ctime > sstat.mtime);
   }
}
