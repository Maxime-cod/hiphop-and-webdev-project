/*=====================================================================*/
/*    .../project/hop/hop/node_modules/hopc/node/hop-loader.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Fri Nov 17 08:15:59 2023                          */
/*    Last change :  Fri Jul  5 20:32:30 2024 (serrano)                */
/*    Copyright   :  2023-24 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    hop loader/resolver loaders.                                     */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { readFile, writeFile, lstat, rename } from 'node:fs/promises';
import { features } from 'node:process';
import { existsSync, writeSync } from 'fs';
import { normalize, dirname, basename, extname, resolve as resolvePath } from 'node:path';
import { cwd } from 'node:process';
import { fileURLToPath, pathToFileURL, URL } from 'node:url';

const hopCompiler =
   (features.hop ? "./hopc-hop-compiler.hop" : "./hopc-js-compiler.mjs");
let hopCompile = false;

/*---------------------------------------------------------------------*/
/*    debug ...                                                        */
/*---------------------------------------------------------------------*/
function debug(...args) {
/*    args.forEach(a => writeSync(2, a.toString()));                   */
/*    writeSync(2, "\n");                                              */
}

/*---------------------------------------------------------------------*/
/*    isRelative ...                                                   */
/*---------------------------------------------------------------------*/
function isRelative(specifier) {
   return /[.][.]?\//.test(specifier);
}

/*---------------------------------------------------------------------*/
/*    hop extensions                                                   */
/*---------------------------------------------------------------------*/
const extensionsRegex = /\.hop\./;
const autoSuffixes = [".ts", ".mjs", ".js"];

/*---------------------------------------------------------------------*/
/*    resolve ...                                                      */
/*---------------------------------------------------------------------*/
export async function resolve(specifier, context, nextResolve) {
   debug("hop.resolve specifier=", specifier);
   if (extensionsRegex.test(specifier)) {
      const format = await getPackageType(specifier);
      const { url: nurl } = await nextResolve(specifier, { ...context, format });

      const transformedSource = await compile(new URL(nurl));

      return {
	 url: "file://" + transformedSource
      };
   } else if (isRelative(specifier) && !(/\.[^./]+$/.test(specifier))) {
      for (let s of autoSuffixes) {
	 try {
	    const n = await nextResolve(specifier + s);
	 
	    if (n) {
	       return n;
	    }
	 } catch(e) {
	    ;
	 }
      }
      return nextResolve(specifier);
   } else {
      return nextResolve(specifier);
   }
}

/*---------------------------------------------------------------------*/
/*    load ...                                                         */
/*---------------------------------------------------------------------*/
export async function load(url, context, nextLoad) {
   if (extensionsRegex.test(url)) {
      const nurl = await compile(new URL(nurl));
      const format = await getPackageType(nurl);
      
      return nextLoad("file://" + nurl, { ...context, format });
   } else if (isRelative(url) && !(/\.[^./]+$/.test(specifier))) {
      const suf = autoSuffixes.find(s => existsSync(url + s));

      if (suf) {
	 return load(url + suf, context, nextResolve);
      } else {
	 return nextLoad(url);
      }
   } else {
      return nextLoad(url);
   }
}

/*---------------------------------------------------------------------*/
/*    getPackageType ...                                               */
/*---------------------------------------------------------------------*/
async function getPackageType(url) {
   if (/[.]mjs$/.test(url)) {
      return "module";
   }
   // `url` is only a file path during the first iteration when passed the
   // resolved url from the load() loader
   // an actual file path from load() will contain a file extension as it's
   // required by the spec
   // this simple truthy check for whether `url` contains a file extension will
   // work for most projects but does not cover some edge-cases (such as
   // extensionless files or a url ending in a trailing space)
   const isFilePath = !!extname(url);
   // If it is a file path, get the directory it's in
   const dir = isFilePath ?
      dirname(typeof url === "string" ? url : fileURLToPath(url)):
      url;
   // Compose a file path to a package.json in the same directory,
   // which may or may not exist
   const packagePath = resolvePath(dir, 'package.json');
   // Try to read the possibly nonexistent package.json
   const type = await readFile(packagePath, { encoding: 'utf8' })
      .then((filestring) => JSON.parse(filestring).type)
      .catch((err) => {
	 if (err?.code !== 'ENOENT') console.error(err);
      });
   // Ff package.json existed and contained a `type` field with a value, voila
   if (type) return type;
   // Otherwise, (if not at the root) continue checking the next directory up
   // If at the root, stop and return false
   return dir.length > 1 && getPackageType(resolvePath(dir, '..'));
} 

/*---------------------------------------------------------------------*/
/*    compile ...                                                      */
/*---------------------------------------------------------------------*/
export async function compile(url) {
   if (!hopCompile) {
      hopCompile = (await import(hopCompiler)).compile;
   }

   const path = fileURLToPath(url);
   const target = dirname(path)
      + "/._"
      + basename(path).replace(/^\._/, "").replace(extensionsRegex, ".");

   if (await newer(target, path)) {
      return target;
   } else {
      const conf = path.match(/\.ts$/) ? { typescript: true, importFrom: "@hop/hop" } : {importFrom: "@hop/hop"};
      const prog = hopCompile(path, target, conf);

      if (!prog) {
	 return path;
      } else {
	 return prog;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    newer ...                                                        */
/*---------------------------------------------------------------------*/
async function newer(target, source) {
   if (!existsSync(target)) {
      return false;
   } else {
      const tstat = await lstat(target);
      const sstat = await lstat(source);
      
      return (tstat.ctime > sstat.mtime);
   }
}
