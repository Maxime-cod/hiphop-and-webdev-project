/*=====================================================================*/
/*    .../prgm/project/hop/hop/node_modules/hopc/node/lexer.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sat Sep 16 12:26:16 2023                          */
/*    Last change :  Thu Jul 11 16:03:08 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    JavaScript lexer                                                 */
/*=====================================================================*/
"use strict";
"use hopscript";

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { Token } from "./token.mjs";
import { Lexer, makePortLoc } from "./reader.mjs";
import { cons } from "./list.mjs";

/*---------------------------------------------------------------------*/
/*    jsRules ...                                                      */
/*---------------------------------------------------------------------*/
const jsRules = [
   // shebang
   {rx: /#![ \t]*\/.*/y, type: "SHEBANG"},
   // blank
   {rx: /[ \t]+/y, type: "BLANK"},
   {rx: /[ \t]*[\n][ \t]*/y, type: "NEWLINE"},
   // comments
   {rx: /\/\/[^\n\r]*/y, type: "LINECOMMENT" },
   {rx: /\/[*](?:[^*]|[*][^/])*[*]+\//my, type: "COMMENT" },
   // numbers
   {rx: /0|[1-9][0-9]*/y, type: "NUMBER" },
   {rx: /0[1-9][0-9]*/y, type: "OCTALNUMBER" },
   {rx: /(?:[0-9]+[eE]?-[0-9]+|[0-9]+\.[0-9]*|\.[0-9]+|[eE][-+]?[0-9]+|0x[0-9a-fA-F]+|[0o][0-7]+)/y, type: "NUMBER"},
   {rx: /(?:-?|0x)[0-9]+n/y, type: "BIGINT"},
   // dollar
   {rx: /[$]{/y, type: "DOLLAR" },
   {rx: /~{/y, type: "TILDE" },
   // identifiers
   {rx: /[$_a-zA-Z][$_a-zA-Z0-9]*/y, type: "ID"},
   {rx: /#[$_a-zA-Z][$_a-zA-Z0-9]*/y, type: "SHARPID"},
   // parenthesis
   {rx: /{/y, type: "LBRACE"},
   {rx: /}/y, type: "RBRACE"},
   {rx: /\(/y, type: "LPAREN"},
   {rx: /\)/y, type: "RPAREN"},
   {rx: /\[/y, type: "LBRACKET"},
   {rx: /\]/y, type: "RBRACKET"},
   // punctuation
   {rx: /#/y, type: "SHARP"},
   {rx: /[.]/y, type: "DOT"},
   {rx: /;/y, type: "SEMICOLON"},
   {rx: /:/y, type: ":"},
   {rx: /,/y, type: "COMMA"},
   {rx: /[|]/y, type: "BIT_OR"},
   {rx: /[|][|]/y, type: "OR"},
   // bitwise
   {rx: /\|/y, type: "BIT_OR"},
   {rx: /\//y, type: "/"},
   {rx: /\/=/y, type: "/="},
   {rx: /[-<>+*%&^!~:=?]/y, type: "__SELF__"},
   {rx: /<=|>=|=?=?=|!=?=?|[*][*]|[+][+]|--|<<|>>|>>>|&&|[+]=|-=|[*]=|%=|<<=|>>=|>>>=|&=|\^=|\/=|[*][*]=|[?][?]|[?][.]|[?][?]=|&&=/y, type: "__SELF__"},
   {rx: /\|\|=/y, type: "=OR"},
   {rx: /=>/y, type: "=>"},
   {rx: /[.]{3}/y, type: "DOTS"},
   // strings
   {rx: /"([^"\r\n]*)"|'([^'\r\n]*)'/y, type: "STRING"},
   {rx: /`/y, type: "TEMPLATE"},
   // HTML
   {rx: /<[_0-9a-zA-Z][0-9a-zA-Z_.:]*>/y, type: "OTAG"},
   {rx: /<[_0-9a-zA-Z][0-9a-zA-Z_.:]*[ \t\n]+(?:[0-9]*[_0-9a-zA-Z][0-9a-zA-Z_.:]*|[$][{]|\/?>)/y, type: "OHTML"},
   {rx: /<[_0-9a-zA-Z][0-9a-zA-Z_.:]*\/>/y, type: "HTML"},
   {rx: /<\/[_0-9a-zA-Z][0-9a-zA-Z_.:]*>/y, type: "CTAG"},
   {rx: /<![_0-9a-zA-Z][0-9a-zA-Z_.:]*[^>]+>/y, type: "DOCTYPE"},
   {rx: /<!--(?:[^-]|-[^-]|--[^>]\n)+[-]*->/my, type: "HTMLCOMMENT"}
];

/*---------------------------------------------------------------------*/
/*    reserved keywords                                                */
/*---------------------------------------------------------------------*/
const keyword = new Map([
   ["await", true],
   ["break", true],
   ["case", true],
   ["catch", true],
   ["const", true],
   ["continue", true],
   ["debugger", true],
   ["default", true],
   ["delete", true],
   ["do", true],
   ["else", true],
   ["false", true],
   ["finally", true],
   ["for", true],
   ["function", true],
   ["if", true],
   ["in", true],
   ["instanceof", true],
   ["let", true],
   ["new", true],
   ["null", true],
   ["return", true],
   ["switch", true],
   ["this", true],
   ["throw", true],
   ["true", true],
   ["try", true],
   ["typeof", true],
   ["var", true],
   ["void", true],
   ["while", true],
   ["with", true],
   ["yield", true],
   // es2015 classes
   ["class", true],
   ["extends", true],
   ["super", true]]);
			
const reserved = new Map([
   ["enum", true],
   ["export", true],
   ["import", true]]);

const future = new Map([
   ["implements", true],
   ["interface", true],
   ["package", true],
   ["private", true],
   ["protected", true],
   ["public", true]]);

const typescript = new Map([
   ["as", true],
   ["interface", true],
   ["type", true]]);

/*---------------------------------------------------------------------*/
/*    j2sReservedIdp ...                                               */
/*---------------------------------------------------------------------*/
export function j2sReservedIdp(key) {
   return keyword.get(key);
}

/*---------------------------------------------------------------------*/
/*    J2SLexer ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class J2SLexer extends Lexer {
   eof(port, ...opts) {
      let i = 1;
      while (port.offset - i > 0
	 && port.offset - i < port.buffer.length
	 && port.buffer[port.offset - i].match(/[\n \t]/)) {
	 // on eof find the first non blank character
	 i++;
      }
      port.offset-=i;
      let tok = new Token("EOF", "eof", makePortLoc(port));
      port.offset+=i;
      return tok;
      
   }

   error(port, ...opts) {
      const str = port.buffer.substring(port.offset, port.offset + 20);
      return new Token("ERROR", str + "...", makePortLoc(port));
   }


   match(port, val, rule, ...opts) {
      switch (rule.type) {
	 case "SHEBANG":
	 case "BLANK":
	 case "COMMENT":
	 case "LINECOMMENT":
	    port.offset += val.length;
	    return { res: "", ignore: true };
	 case "ID": {
	    const loc = makePortLoc(port);
	    port.offset += val.length;
	    if (keyword.get(val)) {
	       const res = new Token(val, val, loc);
	       return { res, ignore: false };
	    } else if (reserved.get(val)) {
	       const res = new Token("RESERVED", val, loc);
	       return { res, ignore: false };
	    } else if (typescript.get(val) && opts.find(e => e[1]?.typescript)) {
	       const res = new Token(val, val, loc);
	       return { res, ignore: false };
	    } else {
	       const res = new Token(rule.type, val, loc);
	       return { res, ignore: false };
	    }
	 }
	 case "STRING": {
	    const res = new Token("STRING", val.substring(1, val.length-1), makePortLoc(port));
	    port.offset += val.length;
	    return { res, ignore: false };
	 }
	 case "TEMPLATE": {
	    port.offset++;
	    return { res: templateParser(port), ignore: false };
	 }
	 case "OHTML": {
	    const i = val.match(/[ \t\n]/).index;
	    const res = new Token("OHTML", val.substring(0, i), makePortLoc(port));
	    return { res, ignore: false };
	 }
	 case "HTML": {
	    const res = new Token("HTML", val.substring(0, val.length-2) + ">", makePortLoc(port));
	    port.offset += val.length;
	    return { res, ignore: false };
	 }
	 case "CTAG": {
	    const res = new Token(rule.type, "<" + val.substring(2, val.length-1) + ">", makePortLoc(port));
	    port.offset += val.length;
	    return { res, ignore: false };
	 }
	 case "__SELF__": {
	    const res = new Token(val, val, makePortLoc(port));
	    port.offset += val.length;
	    return { res, ignore: false };
	 }
	 default: {
	    const res = new Token(rule.type, val, makePortLoc(port));
	    port.offset += val.length;
	    return { res, ignore: false };
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    jsLexer ...                                                      */
/*---------------------------------------------------------------------*/
const jsLexer = new J2SLexer(jsRules);

/*---------------------------------------------------------------------*/
/*    j2sLexer ...                                                     */
/*---------------------------------------------------------------------*/
export function j2sLexer() {
   return jsLexer;
}

/*---------------------------------------------------------------------*/
/*    rxLexer ...                                                      */
/*---------------------------------------------------------------------*/
const rxLexer = new J2SLexer([]);
rxLexer.reader = port => rxParser(port);

/*---------------------------------------------------------------------*/
/*    rxParser ...                                                     */
/*---------------------------------------------------------------------*/
function rxParser(port) {
   const buffer = port.buffer;
   let offset = port.offset;

   while (true) {
      let rxoffset = buffer.indexOf("/", offset + 1);
      let rangeoffset = buffer.indexOf("[", offset + 1);
      let escoffset = buffer.indexOf("\\", offset + 1);

      if (rxoffset < 0) {
	 const loc = makePortLoc(port);
	 return new Token("ERROR", buffer[offset], loc);
      }

      if ((rxoffset < rangeoffset || rangeoffset < 0)
	 && (rxoffset < escoffset) ||  (escoffset < 0)) {
	 let j;
	 for (j = rxoffset + 1; "dgimsuvy".indexOf(buffer[j]) >= 0; j++) ;
	 const val = buffer.substring(port.offset, rxoffset);
	 const flags = buffer.substring(rxoffset + 1, j);
	 const loc = makePortLoc(port);
	 port.offset = j;
	 return new Token("RegExp", cons(val, flags), loc);
      } else if (escoffset >= 0 && (escoffset < rangeoffset || rangeoffset < 0)) {
	 offset = escoffset + 1;
      } else {
	 const rangeclo = buffer.indexOf("]", rangeoffset + 1);
	 if (rangeclo > rangeoffset) {
	    offset = rangeclo + 1;
	 } else {
	    const loc = makePortLoc(port);
	    return new Token("ERROR", buffer[offset], loc);
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    j2sRegexLexer ...                                                */
/*---------------------------------------------------------------------*/
export function j2sRegexLexer() {
   return rxLexer;
}

/*---------------------------------------------------------------------*/
/*    j2sTemplateLexer ...                                             */
/*---------------------------------------------------------------------*/
const templateLexer = new Lexer([]);
templateLexer.reader = port => templateParser(port);

export function j2sTemplateLexer() {
   return templateLexer;
}

/*---------------------------------------------------------------------*/
/*    templateParser ...                                               */
/*---------------------------------------------------------------------*/
function templateParser(port) {
   const buffer = port.buffer;
   let offset = port.offset;

   while (true) {
      let idxDollar = buffer.indexOf("$", offset);
      let idxBackquote = buffer.indexOf("`", offset);

      if (idxBackquote < 0) {
	 const loc = makePortLoc(port);
	 return new Token("ERROR", buffer[offset], loc);
      }
      
      if (idxBackquote < idxDollar || idxDollar < 0) {
	 // we are done parsing the string
	 const val = buffer.substring(port.offset, idxBackquote);
	 const loc = makePortLoc(port);
	 port.offset = idxBackquote + 1;
	 return new Token("TSTRING", val.replace(/\r?\n/g, "\\n"), loc);
      } else {
	 // go to the next escape
	 if (buffer[idxDollar + 1] === "{") {
	    // a true escape ${
	    const val = buffer.substring(port.offset, idxDollar);
	    const loc = makePortLoc(port);
	    port.offset = idxDollar + 1;
	    return new Token("TEMPLATE", val.replace(/\r?\n/g, "\\n"), loc);
	 } else {
	    offset = idxDollar + 1;
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    j2sEscapeJsString ...                                            */
/*---------------------------------------------------------------------*/
export function j2sEscapeJsString(s, port) {
   return s;
}
