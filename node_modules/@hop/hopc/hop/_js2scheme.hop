;*=====================================================================*/
;*    .../project/hop/hop/node_modules/hopc/hop/_js2scheme.hop         */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul 17 09:48:30 2018                          */
;*    Last change :  Sat Jun 15 07:36:45 2024 (serrano)                */
;*    Copyright   :  2018-24 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    JS2Scheme wrapper.                                               */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _js2scheme
   
   (library hopscript hop nodejs js2scheme)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)))
	   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this %scope %module)
   
   (js-export (Parser generate compile dump)
      
      (define exports (js-get %module (& "exports") %this))
      
      (define controller #f)
      
      (define (plugin-parse parser this)
	 (unless (isa? parser JsFunction)
	    (js-raise-type-error %this
	       "plugin-parse: wrong parser [~a]" parser))
	 (lambda (tok decl conf ctrl)
	    (set! controller ctrl)
	    (js->ast %this
	       (js-call3 %this parser this
		  (token->js tok)
		  (if (string? decl) (js-string->jsstring decl) decl)
		  conf))))
      
      (define (first-plugin this::JsWrapper)
	 (with-access::JsWrapper this (data)
	    (car (last-pair data))))
      
      (define parse
	 (js-make-function %this
	    (lambda (this path conf)
	       (if (and (isa? this JsWrapper)
			(with-access::JsWrapper this (obj)
			   (eq? obj 'J2SParser)))
		   (let ((filename (js-tostring path %this)))
		      (if (file-exists? filename)
			  (with-access::JsWrapper this (data)
			     (call-with-input-file filename
				(lambda (ip)
				   (set! controller #f)
				   (j2s-parser ip
				      (cons* :debug (bigloo-debug)
					 :module-name (symbol->string (gensym))
					 :plugin-init (cdr (first-plugin this))
					 conf)
				      data))))
			  (raise
			     (instantiate::&io-file-not-found-error
				(proc "parse")
				(msg "file not found")
				(obj filename)))))
		   (js-raise-type-error %this 
		      "js->ast: not a parser [~a]" this)))
	    (js-function-arity 2 0)
	    (js-function-info :name "parse" :len 1)))
      
      (define parseString
	 (js-make-function %this
	    (lambda (this val conf)
	       (if (and (isa? this JsWrapper)
			(with-access::JsWrapper this (obj)
			   (eq? obj 'J2SParser)))
		   (with-access::JsWrapper this (data)
		      (call-with-input-string (js-tostring val %this)
			 (lambda (ip)
			    (set! controller #f)
			    (j2s-parser ip
			       (cons* :debug (bigloo-debug)
				  :module-name (symbol->string (gensym))
				  conf)
			       data))))
		   (js-raise-type-error %this 
		      "js->ast: not a parser [~a]" this)))
	    (js-function-arity 2 0)
	    (js-function-info :name "parseString" :len 1)))
      
      (define (token->js token)
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((tok (js-new0 %this js-object)))
	       (js-bind! %this tok (& "type")
		  :value (js-string->jsstring (symbol->string! (car token)))
		  :writable #f)
	       (js-bind! %this tok (& "value")
		  :value (cond
			    ((symbol? (cdr token))
			     (js-string->jsstring (symbol->string (cdr token))))
			    ((string? (cdr token))
			     (js-string->jsstring (cdr token)))
			    (else
			     (cdr token)))
		  :writable #f)
	       (js-bind! %this tok (& "filename")
		  :value (js-string->jsstring (cadr (cer token)))
		  :writable #f)
	       (js-bind! %this tok (& "pos")
		  :value (caddr (cer token))
		  :writable #f)
	       (js-bind! %this tok (& "location")
		  :value (cer token)
		  :writable #f
		  :enumerable #f)
	       tok)))
      
      (define parser-prototype
	 (with-access::JsGlobalObject %this (js-object)
	    (let ((obj (js-new0 %this js-object)))
	       (js-bind! %this obj (& "parse")
		  :value parse
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseString")
		  :value parseString
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "plugins")
		  :get (js-make-function %this
			  (lambda (this)
			     (with-access::JsWrapper this (data)
				data))
			  (js-function-arity 0 0)
			  (js-function-info :name "get" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "addPlugin")
		  :value (js-make-function %this
			    (lambda (this key parser)
			       (with-access::JsWrapper this (data)
				  (set-cdr! data
				     (cons
					(cons (string->symbol
						 (js-tostring key %this))
					   (plugin-parse parser this))
					(cdr data)))))
			    (js-function-arity 2 0)
			    (js-function-info :name "addPlugin" :len 2))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "removePlugin")
		  :value (js-make-function %this
			    (lambda (this key)
			       (with-access::JsWrapper this (data)
				  (let* ((k (string->symbol
					       (js-tostring key %this)))
					 (c (assq k data)))
				     (delete! c data))))
			    (js-function-arity 1 0)
			    (js-function-info :name "removePlugin" :len 2))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "peekToken")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (token->js
				      ((vector-ref controller 2)))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "peekToken" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "consumeToken")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (token->js
				      ((vector-ref controller 3)
				       (string->symbol
					  (js-tostring token %this))))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "consumeToken" :len 1))
		  :writable #f
		  :enumerable #t)
	       
	       (js-bind! %this obj (& "consumeAny")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (token->js ((vector-ref controller 4)))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "consumeAny" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 5) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parsePrimary")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 0) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parsePrimary" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parsePrimaryDollar")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 1) #f #f data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parsePrimaryDollar" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseCondExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 8) #f #f #t data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseCondExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseAssigExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 10) #f #f #t data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseAssigExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseDollarExpression")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 9) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseDollarExpression" :len 0))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseStatement")
		  :value (js-make-function %this
			    (lambda (this token)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 6) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 1 0)
			    (js-function-info :name "parseStatement" :len 1))
		  :writable #f
		  :enumerable #t)
	       (js-bind! %this obj (& "parseBlock")
		  :value (js-make-function %this
			    (lambda (this)
			       (if (vector? controller)
				   (with-access::JsWrapper this (data)
				      ((vector-ref controller 7) data))
				   (js-raise-type-error %this
				      "detached plugin parser" this)))
			    (js-function-arity 0 0)
			    (js-function-info :name "parseBlock" :len 0))
		  :writable #f
		  :enumerable #t)
	       (for-each (lambda (s)
			    (let ((j (js-ascii-name->jsstring s)))
			       (js-bind! %this obj j :value j :writable #f)))
		  '("DOT" "DOTS" "SEMICOLON" "COMMA" "LBRACE" "RBRACE" "LPAREN"
		    "RPAREN" "ID" "DOLLAR" "LBRACKET" "RBRACKET" "OR" "BIT_OR"
		    "STRING" "await" "break" "case" "catch" "const" "continue"
		    "debugger" "default" "delete" "do" "else" "false" "finally"
		    "for" "function" "if" "in" "instanceof" "let" "new" "null"
		    "return" "switch" "this" "throw" "true" "try" "typeof" "var"
		    "void" "while" "with" "yield" "class" "extends" "super"
		    "static"))
	       (for-each (lambda (ns)
			    (js-bind! %this obj (js-ascii-name->jsstring (car ns))
			       :value (js-ascii->jsstring (cadr ns))
			       :writable #f))
		  '(("ELSE" "else") ("COLUMN" ":") ("EGAL" "=") ("NOTEGAL" "!=")
		    ("EGALEGAL" "==") ("NOTEGALEGAL" "!==")
		    ("LT" "<") ("GT" ">") ("LE" "<=") ("GE" ">=")
		    ("PLUS" "+") ("MINUS" "-") ("MUL" "*") ("PERCENT" "%")
		    ("PLUSPLUS" "++") ("MINUSMINUS" "--") 
		    ("SHIFTL" "<<") ("SHIFTR" ">>") ("USHIFTR" ">>>")
		    ("AMP" "&") ("HAT" "^") ("BANG" "!") ("TILDE" "~") ("AND" "&&")
		    ("PLUSEGAL" "+=") ("MINUSEGAL" "-=") ("MULEGAL" "*=") 
		    ("PERCENTEGAL" "%=") ("SHIFTLEGAL" "<<=") ("SHIFTREGAL" ">>=")
		    ("USHIFTREGAL" ">>>=") ("AMPEGAL" "&=") ("HATEGAL" "^=")
		    ("DIVEGAL" "/=") ("DIV" "/") ("QUESTIONMARK" "?")
		    ("LARROW" "=>")))
	       obj)))

      (define Parser
	 (with-access::JsGlobalObject %this (js-function-prototype)
	    (js-make-function %this
	       (lambda (this)
		  (with-access::JsGlobalObject %this (js-new-target)
		     (if (eq? js-new-target (js-undefined))
			 (js-raise-type-error %this 
			    "Parser must be used as a constructor" this)
			 (begin
			    (set! js-new-target (js-undefined))
			    this))))
	       (js-function-arity 0 0)
	       (js-function-info :name "Parser" :len 0)
	       :__proto__ js-function-prototype
	       :alloc (lambda (%this ctor::JsFunction)
			 (with-access::JsGlobalObject %this (js-new-target)
			    (let ((p (instantiate::JsWrapper
					(obj 'J2SParser)
					(cmap (js-make-jsconstructmap))
					(data (list (cons (gensym) #f))))))
			       (set! js-new-target ctor)
			       (js-object-proto-set! p parser-prototype)
			       (js-object-mode-set! p (js-object-default-mode))
			       p)))
	       :prototype parser-prototype)))

      (define generate
	 (js-make-function %this
	    (lambda (this ast conf)
	       (if (isa? ast J2SProgram)
		   (with-access::J2SProgram ast (nodes path)
		      (let ((s (call-with-output-string
				  (lambda (out)
				     (let ((o (ast->js %this ast)))
					(for-each (lambda (exp)
						     (unless (isa? exp J2SNode)
							(display exp out)))
					   o))))))
			 (js-string->jsstring s)))
		   (js-raise-type-error %this
		      "Not a Hopjs ast" ast)))
	    (js-function-arity 2 0)
	    (js-function-info :name "generate" :len 2)))

      (define compile
	 (js-make-function %this
		   (lambda (this ipath opath)
		      (let ((tgt (j2s-compile ipath "/tmp")))
			 (if (eq? opath (js-undefined))
			     (js-string->jsstring 
				(call-with-output-string
				   (lambda (op)
				      (pp tgt op))))
			     (call-with-output-file (js-tostring opath %this)
				(lambda (op)
				   (pp tgt op)
				   opath)))))
		   (js-function-arity 2 0)
		   (js-function-info :name "compile" :len 2)))

      (define dump
	 (js-make-function %this
		   (lambda (this node)
		      (js-string->jsstring 
			 (call-with-output-string
			    (lambda (s)
			       (pp (j2s->sexp node) s)))))
		   (js-function-arity 1 0)
		   (js-function-info :name "dump" :len 1)))
      
      (js-bind! %this exports (& "Parser")
	 :value Parser
	 :writable #f :enumerable #t)
      
      (js-bind! %this exports (& "compile")
	 :value compile
	 :writable #f
	 :enumerable #t)
      
      (js-bind! %this exports (& "dump")
	 :value dump
	 :writable #f
	 :enumerable #t)))

;*---------------------------------------------------------------------*/
;*    env-debug-compile ...                                            */
;*---------------------------------------------------------------------*/
(define env-debug-compile
   (let ((env (getenv "NODE_DEBUG")))
      (when (string? env)
	 (or (string=? env "compile")
	     (string-prefix? "compile," env)
	     (string-suffix? ",compile" env)
	     (string-contains env ",compile,")))))

;*---------------------------------------------------------------------*/
;*    ast->js ...                                                      */
;*---------------------------------------------------------------------*/
(define (ast->js %this ast::J2SProgram)
   (with-access::J2SProgram ast (path)
      (when env-debug-compile
	 (let ((target "string"))
	    (fprint (current-error-port) (hop-color 1 "" path)
	       " [loader] -> "
	       (if target (hop-color 2 "" target) ""))))
      (with-handler
	 (lambda (err)
	    (fprint (current-error-port) "loader compilation failed for \""
	       path "\"")
	    (exception-notify err)
	    (raise err))
	 (j2s-compile (js->ast %this ast)
	    :warning-global #f
	    :driver (j2s-javascript-plain-driver)
	    :%this %this
	    :es6-module-client #t
	    :loader-resolve (nodejs-make-j2s-loader %this)))))

;*---------------------------------------------------------------------*/
;*    js->ast ...                                                      */
;*---------------------------------------------------------------------*/
(define (js->ast %this n)

   (define (symbol-field? clazz f)
      (or (eq? (class-field-type f) 'symbol)
	  (and (eq? clazz J2SFun) (eq? (class-field-name f) 'idthis))
	  (eq? (class-field-name f) '_scmid)))

   (define (js->scheme v inst clazz f)
      
      (define (err v)
	 (let ((fl (find-class-field clazz 'loc)))
	    (if (class-field? fl)
		(js-raise-type-error/loc %this
		   ((class-field-accessor fl) inst)
		   (format "js->ast: bad field type ~a.~a ~~a" clazz (class-field-name f))
		   v)
		(js-raise-type-error %this 
		   (format "js->ast: bad field type ~a.~a ~~a" clazz (class-field-name f))
		   v))))
      
      (let ((ty (class-field-type f)))
	 (case ty
	    ((symbol)
	     (cond
		((symbol? v) v)
		((string? v) (string->symbol v))
		(else (err v))))
	    ((pair-nil)
	     (cond
		((or (null? v) (pair? v)) v)
		((vector? v) (vector->list v))
		(else (err v))))
	    ((pair)
	     (cond
		((pair? v) v)
		((vector? v) (vector->list v))
		(else (err v))))
	    ((uint32)
	     (cond
		((null? v)
		 (if (class-field-default-value? f)
		     (class-field-default-value f)
		     #u32:0))
		((uint32? v)
		 v)
		((and (fixnum? v) (>=fx v 0))
		 (fixnum->uint32 v))
		(else
		 (err v))))
	    ((symbol-field? clazz f)
	     (cond
		((string? v) (string->symbol v))
		(else v)))
	    (else
	     v))))
	      
   (define (jsobject->node js stk)
      (with-trace '_js2scheme "jsobject->node"
	 (let* ((cname (js-tostring (js-get js (& "__node__") %this) %this))
		(clazz (find-class (string->symbol cname)))
		(ctor (class-constructor clazz))
		(inst ((class-allocator clazz)))
		(fields (class-all-fields clazz))
		(stk (cons (cons js inst) stk)))
	    (trace-item "js.class=" cname)
	    ;; instance fields
	    (let loop ((i (-fx (vector-length fields) 1)))
	       (when (>=fx i 0)
		  (let* ((f (vector-ref-ur fields i))
			 (n (class-field-name f))
			 (jn (js-string->name (symbol->string! n))))
		     (trace-item "jn=" jn)
		     (cond
			((js-has-property js jn %this)
			 (let* ((v (js->node (js-get js jn %this) stk))
				(s (js->scheme v inst clazz f)))
			    (trace-item "v="
			       (if (or (number? s) (symbol? s) (string? s) (null? s) (eq? s #unspecified))
				   s
				   (typeof s)))
			    ((class-field-mutator f) inst s)))
			((class-field-default-value? f)
			 ((class-field-mutator f)
			  inst (class-field-default-value f)))
			((not (member "notraverse" (class-field-info f)))
			 (js-inspect-object js)
			 (error "js->ast"
			    (format "Missing field \"~a\"" n) cname)))
		     (loop (-fx i 1)))))
	    ;; constructor
	    (when (procedure? ctor) ctor inst)
	    (trace-item "inst=" (typeof inst))
	    inst)))

   (define (node->node node stk)
      (with-trace '_js2scheme "node->node"
	 (let* ((clazz (object-class node))
		(cname (class-name clazz))
		(ctor (class-constructor clazz))
		(inst ((class-allocator clazz)))
		(fields (class-all-fields clazz)))
	    (trace-item "scm.class=" cname)
	    (trace-item "node=" (j2s->sexp node))
	    ;; instance fields
	    (let loop ((i (-fx (vector-length fields) 1)))
	       (when (>=fx i 0)
		  (let* ((f (vector-ref-ur fields i))
			 (n (class-field-name f))
			 (v ((class-field-accessor f) node))
			 (fi (class-field-info f)))
		     (trace-item "field=" n " v=" (typeof v)
			" traverse=" (or (not (pair? fi)) (not (member "notraverse" fi))))
		     (cond
			((isa? v J2SNode)
			 (if (and (pair? fi) (member "notraverse" fi))
			     ((class-field-mutator f) inst v)
			     ((class-field-mutator f) inst (js->node v stk))))
			((pair? v)
			 ((class-field-mutator f) inst (map (lambda (v) (js->node v stk)) v)))
			((js-object? v)
			 ((class-field-mutator f) inst (jsobject->node v stk)))
			(else
			 ((class-field-mutator f) inst (js->scheme v inst clazz f))))
		     (loop (-fx i 1)))))
	    ;; constructor
	    (when (procedure? ctor) ctor inst)
	    (trace-item "inst=" (j2s->sexp inst))
	    inst)))

   (define (js->node n stk)
      (with-trace '_js2scheme "js->node"
	 (trace-item "n=" (typeof n))
	 (cond
	    ((assq n stk)
	     =>
	     (lambda (o)
		(trace-item "already processed: " (typeof n))
		(cdr o)))
	    ((isa? n J2SNode)
	     (node->node n stk))
	    ((or (isa? n JsString) (isa? n JsStringLiteral))
	     (js-jsstring->string n))
	    ((isa? n JsSymbolLiteral)
	     (with-access::JsSymbolLiteral n (val)
		(string->symbol (js-jsstring->string val))))
	    ((isa? n JsArray)
	     (map! (lambda (n) (js->node n stk)) (jsarray->list n %this)))
	    ((isa? n JsObject)
	     (let ((n (jsobject->node n stk)))
		(if (isa? n J2SNode)
		    (with-access::J2SNode n (loc)
		       (map! (lambda (n) (js->node n stk)) loc)
		       n)
		    n)))
	    ((pair? n)
	     (map (lambda (n) (js->node n stk)) n))
	    (else
	     n))))

   (with-trace '_js2scheme "js->ast"
      (js->node n '())))
